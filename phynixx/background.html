<!DOCTYPE html>
<!--
 | Generated by Apache Maven Doxia at 2015-01-04 
 | Rendered using Apache Maven Fluido Skin 1.3.1
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="Date-Revision-yyyymmdd" content="20150104" />
    <meta http-equiv="Content-Language" content="en" />
    <title>phynixx - </title>
    <link rel="stylesheet" href="./css/apache-maven-fluido-1.3.1.min.css" />
    <link rel="stylesheet" href="./css/site.css" />
    <link rel="stylesheet" href="./css/print.css" media="print" />

      
    <script type="text/javascript" src="./js/apache-maven-fluido-1.3.1.min.js"></script>

    
                  </head>
        <body class="topBarDisabled">
          
        
    
        <div class="container-fluid">
          <div id="banner">
        <div class="pull-left">
                                <div id="bannerLeft">
                <h2>Phynixx's Parent Project</h2>
                </div>
                      </div>
        <div class="pull-right">  </div>
        <div class="clear"><hr/></div>
      </div>

      <div id="breadcrumbs">
        <ul class="breadcrumb">
                
                    
                  <li id="publishDate">Last Published: 2015-01-04
                      <span class="divider">|</span>
                   </li>
                  <li id="projectVersion">Version: 2.0.0-SNAPSHOT
                      </li>
                      
                
                    
      
                            </ul>
      </div>

            
      <div class="row-fluid">
        <div id="leftColumn" class="span3">
          <div class="well sidebar-nav">
                
                    
                <ul class="nav nav-list">
                    <li class="nav-header">Phynixx</li>
                              
      <li>
  
                          <a href="project-info.html" title="Project Information">
          <i class="none"></i>
        Project Information</a>
            </li>
                              <li class="nav-header">Documentation</li>
                              
      <li>
  
                          <a href="getting-started.html" title="Getting Started">
          <i class="none"></i>
        Getting Started</a>
            </li>
                
      <li>
  
                          <a href="tutorial.html" title="Tutorial">
          <i class="none"></i>
        Tutorial</a>
            </li>
                
      <li class="active">
  
            <a href="#"><i class="none"></i>Background</a>
          </li>
                
      <li>
  
                          <a href="references.html" title="Referenzen">
          <i class="none"></i>
        Referenzen</a>
            </li>
                              <li class="nav-header">Modules</li>
                              
      <li>
  
                          <a href="phynixx-common/index.html" title="phynixx-common">
          <i class="none"></i>
        phynixx-common</a>
            </li>
                
      <li>
  
                          <a href="phynixx-logger/index.html" title="phynixx-logger">
          <i class="none"></i>
        phynixx-logger</a>
            </li>
                
      <li>
  
                          <a href="phynixx-connection/index.html" title="phynixx-connection">
          <i class="none"></i>
        phynixx-connection</a>
            </li>
                
      <li>
  
                          <a href="phynixx-watchdog/index.html" title="phynixx-watchdog">
          <i class="none"></i>
        phynixx-watchdog</a>
            </li>
                
      <li>
  
                          <a href="phynixx-xa/index.html" title="phynixx-xa">
          <i class="none"></i>
        phynixx-xa</a>
            </li>
                
      <li>
  
                          <a href="phynixx-jmx/index.html" title="phynixx-jmx">
          <i class="none"></i>
        phynixx-jmx</a>
            </li>
                
      <li>
  
                          <a href="phynixx-spring/index.html" title="Unnamed - org.csc:phynixx-spring:jar:2.0.0-SNAPSHOT">
          <i class="none"></i>
        Unnamed - org.csc:phynixx-spring:jar:2.0.0-SNAPSHOT</a>
            </li>
                
      <li>
  
                          <a href="phynixx-tutorial/index.html" title="Tutorial (how to use Phynixx)">
          <i class="none"></i>
        Tutorial (how to use Phynixx)</a>
            </li>
            </ul>
                
                    
                
          <hr />

           <div id="poweredBy">
                            <div class="clear"></div>
                            <div class="clear"></div>
                            <div class="clear"></div>
                            <div class="clear"></div>
                             <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy">
        <img class="builtBy" alt="Built by Maven" src="./images/logos/maven-feather.png" />
      </a>
                  </div>
          </div>
        </div>
        
                
        <div id="bodyColumn"  class="span9" >
                                  
            <p><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /></p>
<p>Transaktionen sind in der aktuellen Datenverarbeitung g&#xe4;ngige Praxis. Jede Verarbeitung auf relationalen Datenbanken nutzt notwendigerweise Transaktionen. Programmiermodelle wie JEE und Spring bieten f&#xfc;r transaktionale Nutzung von Datenbanken weitgehende Unterst&#xfc;tzung, so dass das zu grundeliegende Programmiermodell f&#xfc;r die Anwendung keine gro&#xdf;e Rolle spielt. </p>
<p>Kenntnisse an die Anforderungen an eine Datenbank, an einer Transaktion teilzunehmen, sind i.d.R. nicht notwendig. Vielleicht haben Sie sich mit Konzepten wie <i>isolation level</i> oder <i>locking strategies</i> besch&#xe4;ftigt. Diese Kenntnisse helfen, Datenbanken als Teilnehmer einer Transaktion besser zu verstehen, denn sie ergeben sich unmittelbar aus den Anforderungen, die Transaktionen an Datenbanken stellen. Gl&#xfc;cklicherweise sind die Konzepte durch die Datenbankhersteller gel&#xf6;st. </p>
<p>Sollen allerdings Persistenzsysteme, welche Transktionen nicht unterst&#xfc;tzen (wie z.B. Dateien, Filesysteme oder Archivsysteme), an Transaktionen teilnehmen, so muss man sich mit diesen Anforderungen im einzelnen besch&#xe4;ftigen. </p>
<p>Das Projekt <i>Phynixx</i> bietet die M&#xf6;glichkeit, Persistenzsysteme ohne Transaktionsunterst&#xfc;tzung, so zu erweitern, dass diese an Transaktionen teilnehmen k&#xf6;nnen. <i>Phynixx</i> bietet die notwendigen Werkzeuge, diese Systeme an das transaktionale Programmiermodell anzupassen. <i>Phynixx</i> arbeitet im Javaumfeld, so dass die Anpassung f&#xfc;r das transaktionale Programmiermodell in Java gilt.</p>
<p>Im ersten Teil dieses Dokuments werden die notwendigen Definitionen und Konzepte des transaktionalen Programmiermodells in Java erl&#xe4;utert. Im zweiten Teil wird untersucht, welche Auswirkungen die Anforderungen auf das zu unterst&#xfc;tzende Persistenzsystem haben und wie <i>Phynixx</i> dort unterst&#xfc;tzen kann. </p>
<p>Eine konkrete Umsetzung der Konzepte mit <i>Phynixx</i> wird anhand des Beispiels des sequentiellen Schreibens in eine Datei im Tutorial (siehe <a href="tutorial.html">Tutorial</a>) vorgestellt.</p>
<p>Um Konzepte zu verstehen, bietet es sich an, Datenbanksysteme als prototypische Teilnehmer an einer Transaktion im Hinterkopf zu halten. Sie werden alle hier vorgestellten Konzepte dort wiederfinden. </p>
<h1>Transaktionen - grundlegende Konzepte</h1>
<p>Eine Transaktion ist eine Verarbeitung von Daten, die als prim&#xe4;res Ziel hat, die Korrektheit der Daten jedes der beteiligten System zu gew&#xe4;hrleisten. </p>
<p>Eine Transaktion ist ein lediglich eine programmatische Klammer f&#xfc;r &#xc4;nderungen, welche an Systemen wie Datenbanken, Messagequeues o.&#xe4;. vorgenommen werden. </p>
<p>Das klassische Beispiel einer Transaktion ist die &#xdc;berweisung zwischen Konten unterschiedlicher Banken. Die Wertstellungen der beiden Konten m&#xfc;ssen entweder beide stattfinden oder beide nicht.<br />Innerhalb einer Transaktionen k&#xf6;nnen mehrere &#xdc;berweisungen get&#xe4;tigt werden. Entweder sollen diese insgesamt oder gar nicht wertgestellt werden. </p>
<p>Relationale Datenbanksysteme sind am h&#xe4;ufigsten als teilnehmende Systeme/Ressourcen in Transaktionen zu finden. Im Javaumfeld sind aber auch andere Ressourcen wie JMS zu finden. </p>
<p>Neben diesen beiden Systemen existiert im Javaumfeld wenig Unterst&#xfc;tzung f&#xfc;r andere Ressourcen, die sich an Transaktionen beteiligen m&#xf6;chten. Dazu geh&#xf6;ren Dateien, Filesysteme, Archivsysteme und andere Persistenzsysteme. </p>
<div class="section">
<h2>Eigenschaften einer Transaktion - ACID<a name="Eigenschaften_einer_Transaktion_-_ACID"></a></h2>
<p>Um dem Ziel der Korrektheit gerecht zu werden, unterst&#xfc;tzen Transaktionen Eigenschaften, welche mit dem bekannten Akronym <b>ACID</b> beschrieben werden.</p>
<div class="section">
<h3>Atomicity<a name="Atomicity"></a></h3>
<p>F&#xfc;r alle beteiligten Ressourcen werden entweder <b>alle</b> (<i>commit</i>) oder <b>keine</b> der Ver&#xe4;nderungen durchgef&#xfc;hrt (<i>rollback</i>). Die Ver&#xe4;nderungen innerhalb einer Transaktion kommen entweder ganz oder gar nicht zum Tragen.</p>
<p>Dieser Ansatz setzt voraus, dass jede Ressource ihre eigenen &#xc4;nderungen innerhalb der Transaktion protokolliert. Eine Ressource, die in eine Transaktion involiert ist, besitzt daher einen transaktionalen Zustand (<b><i>transactional state</i></b>). Dieser transaktionale Zustand beschreibt die Menge an &#xc4;nderungen, welche einem <i>commit/rollback</i> unterliegen. Die Art und Weise, wie eine Resource die &#xc4;nderungen protokolliert, bleibt ihr &#xfc;berlassen. Entscheidend ist, dass im Fall eines <i>commit</i> alle &#xc4;nderungen durchgef&#xfc;hrt werden, bzw. im Fall eines <i>rollback</i> keine der &#xc4;nderungen aktiv wird.</p></div>
<div class="section">
<h3>Consistency<a name="Consistency"></a></h3>
<p>Konsistenz ist eine Anforderungen an die fachliche Logik, die innerhalb einer Transaktion umgesetzt wird, und nicht eine Anforderung an die Transaktion selbst. Transaktionen wissen nichts &#xfc;ber die Sematik der &#xc4;nderungen. </p>
<p>Konsistenz bleibt daher immer Aufgabe der Programmlogik.</p></div>
<div class="section">
<h3>Isolation<a name="Isolation"></a></h3>
<p>Zwischenzeitliche &#xc4;nderungen an der Resource innerhalb der Transaktion sind nur in der Transaktion sichtbar. Relationale Datenbanken bieten i.d.R. unterschiedliche Level von Isolation an ( siehe <a class="externalLink" href="http://www.oracle.com/technetwork/issue-archive/2010/10-jan/o65asktom-082389.html">http://www.oracle.com/technetwork/issue-archive/2010/10-jan/o65asktom-082389.html</a>) , die teilweise lesenden Zugriff auf innerhalb einer anderen Transaktion ver&#xe4;nderter Daten zulassen. Mindestens muss aber der Grad an Isolation sicherstellen, dass die Daten, die in einer Transaktion ge&#xe4;ndert werden, nicht gleichzeitig durch eine andere Transaktion ge&#xe4;ndert werden k&#xf6;nnen.</p>
<p>Diese Forderung der Isolation wird i.d.R. (zumindest bei vielen Datenbanken, JMS) durch ein pessimistisches Sperrkonzept (<i>locking</i>) umgesetzt. Wird eine Ressource innerhalb Transaktion ver&#xe4;ndert, so muss diese gegen&#xfc;ber allen anderen Transaktion gegen &#xc4;nderungen gesch&#xfc;tzt werden. Dies geschieht, indem sie vor der &#xc4;nderung gesperrt wird. Pessimistische Sperren m&#xfc;ssen vor dem ersten Zugriff auf die zu ver&#xe4;ndernden Daten gesetzt werden. Als Konsequenz ergibt sich die Gefahr von <i>Deadlocks</i> ( - gegenseitiges Warten unterschiedlicher Transaktionen auf die Aufhebung einer Sperre) und sie k&#xf6;nnen unter ung&#xfc;nstigen Voraussetzungen die Parallelsierung der Verarbeitung stark einschr&#xe4;nken. </p>
<p>Insbesondere m&#xfc;ssen alle Transaktionen diese Ressource und ihren alle konkurrierend zu ver&#xe4;ndernden Daten kennen. Dies setzt voraus, dass die Ressource auf einem gemeinsamen, f&#xfc;r alle Transaktionen (und damit deren ausf&#xfc;hrende Prozesse) sichtbaren Datenbestand operiert. Dieser zentralistische Ansatz ist in Zeiten von Big Data nicht immer einzuhalten. Nach dem CAP-Theorem (siehe <a class="externalLink" href="http://www.allthingsdistributed.com/2007/12/eventually_consistent.html">http://www.allthingsdistributed.com/2007/12/eventually_consistent.html</a>) bedingt dieser Ansatz Abstriche bei der Parallelisierung. Es ist also nicht immer dieses starke Ma&#xdf; an Konsistenz w&#xfc;nschenswert.</p></div>
<div class="section">
<h3>Durability<a name="Durability"></a></h3>
<p>Aus Datenbanken ist bekannt, dass die &#xc4;nderungen am Datenbestand persistiert werden und nach der erfolgreichen Transaktion au&#xdf;erhalb des ver&#xe4;ndernden Prozesses bekannt sind. Diese Forderung ist bei den bekannten transaktionalen Ressourcen wie Datenbanken und JMS gegeben. </p>
<p>Es lassen sich aber auch Szenarien von Transaktionen und Ressourcen vorstellen, in denen die Dauerhaftigkeit der Daten keine Rolle spielt. Z.B. spielt die Kopplung des <i>command pattern</i> mit Transaktionen und Persistenzsystemen eine gro&#xdf;e Rolle, um die Konsistenz von Anwendungen sicherzustellen. Die <i>commands</i> des <i>command pattern</i> werden nicht dauerhaft gespeichert. Daher eignen sich leichtgewichtigere Ans&#xe4;tze, um <i>command pattern</i> in Transaktionen einzubetten. </p></div></div>
<div class="section">
<h2>Lokale Transaktionen<a name="Lokale_Transaktionen"></a></h2>
<p>Die Verbindung einer Ressourcen zu einer Transaktion wird i.d.R. als <i>connection</i> oder <i>physical connection</i> bezeichnet. *Connection*s stellen die Schnittstelle zur Semantik der Ressource dar. Z.B. beschreibt <i>javax.sql.Connection</i> eine Connection zu einer relationalen Datenbank einschlie&#xdf;lich eines Zugriffsinterface auf eine Datenbankverbindung. Es werden SQL-Statements abgesetzt oder Stored-procedures aufgerufen. Dieses Interface ist f&#xfc;r den Zugriff auf die Datenbankverbindung spezifisch. Im allgemeinen ist die Struktur und Schnittstelle einer <i>Connection</i> ist nicht standardisiert ist, sondern obliegt der Implementierung der Ressource. </p>
<p>Aus der <i>Atomicity</i> ergibt sich, dass eine Ressource ihren transaktionalen Zustand w&#xe4;hrend der Transaktion protokollieren und verwalteten muss (<i>transactional state</i>). Die verantwortlichkeit f&#xfc;r den <i>transactional state</i> ist alle Typen von <i>connections</i> gemeinsam. </p>
<p><i>connections</i> bieten die Methoden <i>commit/rollback</i>-Methoden (oder semantisch vergleichbare Methoden), mittels der die &#xc4;nderungen des <i>transactional state</i> best&#xe4;tigt oder verworfen werden. </p>
<p>Falls sich die Anwendung mit einer einzelnen Ressource verbindet, dort &#xc4;nderungen vornimmt und diese dann mittels <i>commit</i> best&#xe4;tigt oder mit <i>rollback</i> verwirft, so spricht man von einer <b>lokalen Transaktion</b>.</p>
<p><i>commit/rollback</i> werden direkt auf dieser Ressource durchgef&#xfc;hrt (z.B. Datenbank-Connection) und es bedarf keiner &#xfc;bergeordneten Koordination der Transaktion, denn es ist nur eine Partei involviert.</p>
<p>Abbildung 1 zeigt die m&#xf6;glichen Zustands&#xfc;berg&#xe4;nge einer lokalen Transaktion. </p>
<p><img src="images/1PhaseCommit.png" alt="single phase commit" /></p>
<p><i>Abbildung 1:</i> Zustands&#xfc;berg&#xe4;nge bei einer lokalen Transaktion (nach <a class="externalLink" href="http://dsl.serc.iisc.ernet.in/publications/thesis/rkg.ps.gz">gupta-1997</a> Kap 3.2.1)</p></div>
<div class="section">
<h2>JTA Transaktionen<a name="JTA_Transaktionen"></a></h2>
<p>Nehmen mehr als eine Ressource an der Transaktion teil, so reicht ein einfaches <i>rollback/commit</i>-Protokoll nicht mehr aus, sondern die Ressourcen m&#xfc;ssen koordiniert werden.</p>
<p>Die Koordination umfasst folgenden Aufgaben:</p>

<ul>
  
<li>Informierung aller Ressourcen &#xfc;ber anstehendes <i>commit/rollback</i>.</li>
  
<li>Koordination des <i>rollback/commit</i> der einzelnen Ressourcen untereinander.</li>
  
<li>Verfahren zur Aufl&#xf6;sung von Konflikten w&#xe4;hrend <i>commit/rollback</i> zwischen den einzelnen Ressourcen.</li>
  
<li>Recovery-Verfahren, wenn w&#xe4;hrend <i>rollback/commit</i> Fehler aufgetreten sind (siehe unten).</li>
</ul>
<p>Insbesondere muss der Konflikt gel&#xf6;st werden, dass eine Ressource bei der Durchf&#xfc;hrung ihres <i>commits</i> Probleme feststellt und auf ein <i>rollback</i> schwenken muss. Was passiert mit den anderen Ressourcen, welche im schlimmsten Fall bereits ihr <i>commit</i> durchgef&#xfc;hrt haben?</p>
<p>Diese Koordination wird durch einen <i>Transaction Manager</i> durchgef&#xfc;hrt. Im Javaumfeld werden die Anforderungen an einen solchen <i>Transaction Manager</i> durch die Spezifikation <i>JTA (Java Transaction API)</i> <a class="externalLink" href="https://www.google.de/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;ved=0CDIQFjAA&amp;url=https%3A%2F%2Fjava.net%2Fprojects%2Fjta-spec%2Fsources%2Fspec-source-repository%2Fcontent%2Fjta-1_2-spec_v2.pdf%3Frev%3D14&amp;ei=J4IoU7ThJayv7Abx4IGgBg&amp;usg=AFQjCNHLwJXJjakdMcMhkWKl8MqIX7KJvA&amp;sig2=3jB0IV-PkKLUE1gWUwudOA&amp;bvm=bv.62922401,d.ZGU&amp;cad=rja" title="Spezifikation von JTA 1.2">JTA</a> definiert. </p>
<p>Dazu dient das <i>2 Phase Commit</i>-Protokoll. W&#xe4;hrend der Phase, in der auf der <i>Connection</i> Anwendungslogik ausgef&#xfc;hrt wird und w&#xe4;hrend des <i>rollbacks</i> unterscheidet sich das <i>2 Phase Commit</i>-Protokoll nicht vom <i>Single Phase Commit</i>-Protokoll, wie es bei <i>lokalen Transaktionen</i> vorgestellt wurde. </p>
<p>Das <i>Commit</i> verl&#xe4;uft dagegen in zwei Phasen. In der Phase <i>prepare</i> wird die <i>Connection</i> von Transaktionsmanager gebeten, ein <i>Commit</i> vorzubereiten. Zu diesem Zeitpunkt kann die Ressource gegen ein <i>Commit</i> votieren und damit die gesamte Transaktion abbrechen lassen. Haben alle Ressourcen einem <i>commit</i> zugestimmt, so gibt es kein Zur&#xfc;ck und in der n&#xe4;chsten Phase fordert der Transaktionsmanager alle Ressourcen auf, ein <i>commit</i> auszuf&#xfc;hren.</p>
<p>Dieses ist f&#xfc;r Java-Ressourcen in <a class="externalLink" href="https://www.google.de/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;ved=0CDIQFjAA&amp;url=https%3A%2F%2Fjava.net%2Fprojects%2Fjta-spec%2Fsources%2Fspec-source-repository%2Fcontent%2Fjta-1_2-spec_v2.pdf%3Frev%3D14&amp;ei=J4IoU7ThJayv7Abx4IGgBg&amp;usg=AFQjCNHLwJXJjakdMcMhkWKl8MqIX7KJvA&amp;sig2=3jB0IV-PkKLUE1gWUwudOA&amp;bvm=bv.62922401,d.ZGU&amp;cad=rja" title="Spezifikation von JTA 1.2">JTA 1.2</a> beschrieben. JTA basiert auf diesem auch als XA-Protokoll bezeichneten <i>2 phase commit protocol (2PC)</i>, welche in <a class="externalLink" href="http://www.opengroup.org/onlinepubs/009680699/toc.pdf" title="XA Specification">XA</a> spezifiziert ist. </p>
<p>Befinden sich der <i>transaction manager</i> und die beteiligten Ressource nicht in einem gemeinsamen Proze&#xdf;, sondern sind auf unterschiedliche Prozesse/Knoten aufgeteilt, so gilt die Transaktion als verteilt (<i>distributed transaction processing DTP</i>). Dieses Szenario stellt gr&#xf6;&#xdf;ere Anforderungen an den <i>transaction manager</i>, die einzelnen Ressourcen zu koordinieren. Da dieses Szenario keinerlei Auswirkungenn auf die beteiligten Ressourcen hat und <i>Phynixx</i> sich mit der Unterst&#xfc;tzung dieser Ressourcen besch&#xe4;ftigt, gehen wir nicht n&#xe4;her auf verteilte Transaktionen ein. </p>
<div class="section">
<h3>Zustands&#xfc;berg&#xe4;nge einer TA-gesicherten Resource<a name="Zustandsbergnge_einer_TA-gesicherten_Resource"></a></h3>
<p>In <a class="externalLink" href="http://dsl.serc.iisc.ernet.in/publications/thesis/rkg.ps.gz">gupta-1997</a> Kap 3.2.1 sind die Zustands&#xfc;berg&#xe4;nge einer transaktionsgesicherten Ressource in einem <i>2 phase commit</i>-Protokoll beschrieben. (Abort(-ing) entspricht dem g&#xe4;ngigeren rollback(-ing).)</p>
<p>Bzgl. des <i>1 phase commit protocols</i> lassen diese wie in Abbildung 1 reduzieren.</p>
<p><img src="images/2PhaseCommit.png" alt="two phase commit" /></p>
<p><i>Abbildung 2:</i> Zustands&#xfc;berg&#xe4;nge bei 2 Phase Commit (nach <a class="externalLink" href="http://dsl.serc.iisc.ernet.in/publications/thesis/rkg.ps.gz">gupta-1997</a> Kap 3.2.1)</p></div></div>
<div class="section">
<h2><i>ResourceManager</i> und <i>TransactionManager</i><a name="ResourceManager_und_TransactionManager"></a></h2>
<p>In JTA wird die teilnehmende Ressource durch einen <b><i>ResourceManager</i></b> rep&#xe4;sentiert. Dieser ist zust&#xe4;ndig, eine Verbindung zur Ressource innerhalb einer Transaktion aufzubauen, die Verbindung zwischen Transaktion und Ressource zu verwalten und den transaktionalen Zustand der Ressource bzgl. dieser Transaktion zu pflegen. </p>
<p>Die Beziehung zwischen <i>ResourceManager</i> und <i><b>TransactionManager</b></i> wird &#xfc;ber die sogenannte <b><i>XAResource</i></b> beschrieben. <i>XAResource</i> definiert, wie der <i>TransactionManager</i> mit dem <i>ResourceManager</i> kommuniziert. Dort wird unter anderem beschrieben, wie der <i>TransactionManager</i> dem <i>ResourceManager</i> mitteilt, dass eine neue Transaktion er&#xf6;ffnet oder geschlossen wird.</p>
<p><img src="images/resourcemanager-transactionmanager-jta12.jpg" alt="resourcemanager-transactionmanager-jta12" /> <i>Abbildung 2</i> : Beziehung zwischen <i>ResourceManager</i> und <i>TransactionManager</i> gem&#xe4;&#xdf; <a class="externalLink" href="https://www.google.de/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;ved=0CDIQFjAA&amp;url=https%3A%2F%2Fjava.net%2Fprojects%2Fjta-spec%2Fsources%2Fspec-source-repository%2Fcontent%2Fjta-1_2-spec_v2.pdf%3Frev%3D14&amp;ei=J4IoU7ThJayv7Abx4IGgBg&amp;usg=AFQjCNHLwJXJjakdMcMhkWKl8MqIX7KJvA&amp;sig2=3jB0IV-PkKLUE1gWUwudOA&amp;bvm=bv.62922401,d.ZGU&amp;cad=rja" title="Spezifikation von JTA 1.2">JTA 1.2</a></p>
<p>Die Verbindung einer globalen Transaktion mit einer Ressource umfasst neben dem transaktionalen Zustand noch das Wissen um die aktuelle Transaktion und den aktuellen Zustand bzgl. dieser Transaktion. Diese Kombination aus <i>XAResource</i> und <i>Connection</i> (im wesentlichen <i>transaktionale Zustand</i>) hei&#xdf;t <i>transaktionale Ressource</i> (<b><i>transactional resource</i></b>)</p>
<p>Die einzelnen Zustands&#xfc;berg&#xe4;nge werden zwar vom Transaktionsmanager mitgeteilt, der aktuelle Status und evtl. zul&#xe4;ssige Status&#xfc;berg&#xe4;nge werden durch die <i>transactional resource</i> validiert und schlie&#xdf;lich durchgef&#xfc;hrt.</p>
<div class="section">
<h3>Verbindungsaufnahme<a name="Verbindungsaufnahme"></a></h3>
<p>Eine JTA-Transaktion wartet darauf, dass sich die Ressource bei ihr anmeldet, um an der Transaktion teilzunehmen. Es ist Aufgabe der Ressource zu erkennen, wann sie an einer Transaktion teilnehmen m&#xf6;chte. In diesem Fall meldet sie sich bei der Transaktion an.</p>
<p>Die Anwendungslogik nutzt eine <i>Connection</i>, um mit dieser Verbindung die zugrunde liegende Ressource zu ver&#xe4;ndern. </p>
<p>Der komplexe Prozess, wie sich die Ressource an einer Transaktion anmeldet und die zugeh&#xf6;rige <i>connection</i> aufbaut, l&#xe4;uft versteckt und im Hintergrund ab. </p>
<p>Die <i>Connection</i> wird durch den <i>RessourceManager</i> geliefert. Dieser pr&#xfc;ft, ob eine aktuelle Transaktion vorliegt und ob die aktuelle Ressource bereits an dieser teilnimmt. <i>Abbildung 3</i> zeigt den Anmeldungsprozess, welcher durch die Anforderung einer <i>connection</i> durch die Anwendungslogik ausgel&#xf6;st wird. Nach dieser Anmeldung hat die Anwendungslogik Zugriff auf eine <i>connection</i>. Die Ressource hat sich mit einer <i>XAResource</i> bei der Transaktion angemeldet und verwaltet die zugeh&#xf6;rige <i>connection</i> und damit den <i>transactional state</i> der Ressource bzgl. der Transaktion. </p>
<p><img src="images/connection-based-usage-scenario-jta12.png" alt="connection-based-usage-scenario" /></p>
<p><i>Abbildung 3</i> : Zugriff auf eine Connection mit Verbindungsaufnahme im Hintergrund</p>
<p>Globale Transaktionen werden via <i>XAResource.start</i> mit einer <i>transaktionalen Ressource</i> verbunden. Zu einem bestimmten Zeitpunkt darf eine <i>connection</i> h&#xf6;chstens einer Transaktion zugeordnet sein.</p></div>
<div class="section">
<h3>UserTransaction<a name="UserTransaction"></a></h3>
<p>Beginn und Ende einer Transaktion (<i>transaction demarcation</i>) k&#xf6;nnen auf unterschiedliche Weise bestimmt werden</p>

<ul>
  
<li>deklarativ</li>
  
<li>programmatisch</li>
</ul>
<p>Der deklarative Weg erlaubt es, Methoden zu annotieren. Diese Annotationen werden durch transaktionale Aspekte ausgewertet und die durch die Aspekte umschlossene Verarbeitung wird innerhalb einer Transaktion ausgef&#xfc;hrt.</p>
<p>Das Interface <i>UserTransaction</i> erlaubt es Transaktionsgrenzen programmatisch zu bestimmen. Folgendes Codefragment zeigt den Einsatz von <i>UserTransaction</i>, wobei das UserTransaction-Objekt via JNDI bereitgestellt wird. Dieses Szenario beschreibt den Einsatz innerhalb eines ApplicationServers. </p>

<div class="source">
<pre>// get the system property value configured by administrator
String utxPropVal = System.getProperty(&#x201c;jta.UserTransaction&#x201d;);

// use JNDI to locate the UserTransaction object 
Context ctx = new InitialContext();
UserTransaction utx = (UserTransaction)ctx.lookup(utxPropVal);

// start transaction work..
utx.begin();
... do work
utx.commit();
</pre></div></div>
<div class="section">
<h3>Transaktion<a name="Transaktion"></a></h3>
<p>Ein Transktion wird in JTA durch <i>javax.transaction.Transaction</i> repr&#xe4;sentiert. Durch die statische Methode <i>TransactionManager.getTransaction()</i> wird die f&#xfc;r den aktuellen Thread aktive Transaktion vom Transactionmanager bereitgestellt. Er ist f&#xfc;r die korrekte Zuordnung zwischen Thread und Transaktion verantwortlich.</p>
<p>Eine Transaction wird durch einen Transaktion-ID identifiziert, die sogenannte <i>XID</i>. Diese wird durch den Transaktionsmanager der <i>XAResource</i> &#xfc;bergeben, wenn diese eine <i>Connection</i> bereitstellen soll.</p>
<div class="section">
<h4>Transaktionen und Threads<a name="Transaktionen_und_Threads"></a></h4>
<p>Der Transactionmanager ist verantwortlich, die aktive Transaktion zu jedem Zeitpunkt bereitzustellen. Dazu nutzt dieser das Konzept des <i>Thread Context</i>. Ist eine Transaktion f&#xfc;r einen bestimmten Thread aktiv, so wird sie dessen <i>Thread Context</i> zugeordnet. Mit <i>Transactionmanager.getTransaction()</i> wird der <i>Thread Context</i> ausgelesenen und die Transaktion geliefert. Die Spezifikation ( <a class="externalLink" href="https://www.google.de/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;ved=0CDIQFjAA&amp;url=https%3A%2F%2Fjava.net%2Fprojects%2Fjta-spec%2Fsources%2Fspec-source-repository%2Fcontent%2Fjta-1_2-spec_v2.pdf%3Frev%3D14&amp;ei=J4IoU7ThJayv7Abx4IGgBg&amp;usg=AFQjCNHLwJXJjakdMcMhkWKl8MqIX7KJvA&amp;sig2=3jB0IV-PkKLUE1gWUwudOA&amp;bvm=bv.62922401,d.ZGU&amp;cad=rja" title="Spezifikation von JTA 1.2">JTA 1.2</a> Chap 3.2) l&#xe4;sst ausdr&#xfc;cklich zu, dass sich mehrere Threads eine Transaktion teilen k&#xf6;nnen. Insbesondere kann daher konkurrierender Zugriff auf <i>physical connections</i> stattfinden. </p></div></div>
<div class="section">
<h3>Integration in JEE<a name="Integration_in_JEE"></a></h3>
<p>Der Spezifikation <a class="externalLink" href="https://www.google.de/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;ved=0CDIQFjAA&amp;url=https%3A%2F%2Fjava.net%2Fprojects%2Fjta-spec%2Fsources%2Fspec-source-repository%2Fcontent%2Fjta-1_2-spec_v2.pdf%3Frev%3D14&amp;ei=J4IoU7ThJayv7Abx4IGgBg&amp;usg=AFQjCNHLwJXJjakdMcMhkWKl8MqIX7KJvA&amp;sig2=3jB0IV-PkKLUE1gWUwudOA&amp;bvm=bv.62922401,d.ZGU&amp;cad=rja" title="Spezifikation von JTA 1.2">JTA 1.2</a> l&#xe4;sst erkennen, dass diese f&#xfc;r den Einsatz in einem ApplicationServer-Szenario ausgerichtet ist. Ist eine Resource gem&#xe4;&#xdf; <a class="externalLink" href="https://java.net/downloads/connector-spec/connector-1_7-spec-final.pdf" title="JCA Connector Specification 1.7">JCA 1.7</a> entworfen, so wird ihr Lebenszyklus durch den ApplicationServer bestimmt. In <a class="externalLink" href="https://java.net/downloads/connector-spec/connector-1_7-spec-final.pdf" title="JCA Connector Specification 1.7">JCA 1.7</a> Cap. 7 ist der Zusammenhang zwischen einer JCA-Resource und einem JTA-TransactionManager beschrieben. </p></div></div>
<div class="section">
<h2>1x1 der Transaktionen<a name="a1x1_der_Transaktionen"></a></h2>

<table border="0" class="table table-striped">

<tr class="a">
<th></th>
<th>Beschreibung</th> 
<th>in JTA standardisiert</th></tr>

<tr class="b">
<td>Transaktionsmanager</td> 
<td>Koordiniert eine Transaktion</td> 
<td>X</td></tr>

<tr class="a">
<td>Connection</td> 
<td>*Connection* repr&#xe4;sentiert eine Verbindung zu einer Ressource. Insbesondere verwaltet die Connection die in dieser Transaktion an der Ressource vorgenommen &#xc4;nderungen (*transactional state*) </td>
<td>&#160;-&#160;&#160; (i.d.R. in den jeweiligen Spezifikationen wie JDBC, JMS)</td> </tr>

<tr class="b">
<td>transaktionale&#160;Ressource</td> 
<td>Ressource, die an einer Transaktion teilnimmt (z.B. Datenbank). Sie verwaltet den Zustand de Resource bzgl. der Transaktion (inkl. *Connection*)</td> 
<td>-</td></tr>

<tr class="a">
<td>lokale Transaktion</td> 
<td>Transaktion, die direkt auf einer transaktionalen Ressource wirken</td>
<td>X</td> </tr>

<tr class="b">
<td>XA-Transaktion (aka&#160;globale Transaktion)</td> 
<td>verteilte oder auch 2 Phase Commit Transaktion; Transaktion, an der mehr als eine transaktionale Ressource teilnimmt</td> </tr>

<tr class="a">
<td>ResourceManager</td> 
<td>liefert Verbindung zur Ressource innerhalb einer Transaktion und liefert die Connection</td> 
<td>&#160;-&#160;</td> </tr>

<tr class="b">
<td>XA-Resource</td> 
<td>Schnittstelle zwischen ResourceManager und TransaktionsManager</td>
<td>X</td> </tr>
</table>
<h1>Anforderungen an <i>transaktionale Resourcen</i></h1>
<p>Mit den wichtigsten Begriff aus dem Umfeld von Transaktionen im Gep&#xe4;ck, k&#xf6;nnen wir nun untersuchen, welche Anforderungen ein ResourceManager zu erf&#xfc;llen hat, um an Transaktionen (insbesondre JTA-Transaktionen) teilzunehmen.</p>
<p><i>Phynixx</i> hat sich zur Aufgabe gemacht, einen allgemeinen ResourceManager f&#xfc;r Resourcen bereitzustellen, welche von Hause aus kein Transaktionsprotokoll (weder f&#xfc;r lokale noch globale Transaktionen) unterst&#xfc;tzen.</p>
<p>Im Weiteren werden folgende wichtigen Aspekte von transaktionalen Unterst&#xfc;tzung erl&#xe4;utert</p>

<ul>
  
<li>Recovery - Anforderungen an die F&#xe4;higkeit einer Ressource, sich selbst nach schwerwiegenden Systemfehlern in eine korrekten Zustand zu &#xfc;berf&#xfc;hren.</li>
  
<li>Integration in JTA Programmiermodell</li>
  
<li>Unterst&#xfc;tzung der Anforderung &#x2018;Isolation&#x2019; einer Transaktion.</li>
</ul></div>
<div class="section">
<h2>Unterst&#xfc;tzung von <i>Recovery</i><a name="Untersttzung_von_Recovery"></a></h2>
<p>Persistenzsysteme ohne eigene Transaktionssematik (Dateien, Filesysteme, einige Archivsysteme (centera)) m&#xfc;ssen bei ihrer Einbettung in eine Transaktion unterst&#xfc;tzt werden. </p>
<p>Sie m&#xfc;ssen eine <i>connection</i> bereitstellen, welche den transaktionalen Zustand bzgl. der aktuellen Transaktion verwaltet. Desweiteren m&#xfc;ssen sie ein <i>rollback/commit</i> implementieren, um die Transaktion abschlie&#xdf;en zu k&#xf6;nnen. All das spielt sich im Hauptspeicher ab.</p>
<p>Falls w&#xe4;hrend der Transaktion ein schwerwiegender Fehler (z.B. Systemcrash) auftritt, welcher es unm&#xf6;glich macht, die Transaktion definiert zu beenden, kann die Ressource in einem undefinierten und i.d.R. nicht korrekten Zustand verbleiben. In diesen F&#xe4;llen muss die Resource mittels eines Recoverymechanimus in einen korrekten Zustand &#xfc;berf&#xfc;hrt werden. Dies ist nur m&#xf6;glich, wenn w&#xe4;hrend der Transaktion sogenannte <i>Recoveryinformationen</i> persistent protokolliert wurden.</p>
<p>In diesem Fall m&#xfc;ssen die Recoveryinformationen restauriert und auf Basis dieser Informationen das Persistenzsystem in einen korrekten Zustand &#xfc;berf&#xfc;hrt werden.</p>
<p><b>Insbesondere ist Voraussetzung, dass Recoveryinformationen persistent gesichert werden.</b></p>
<p>Befand sich die Transaktion in der <i>rollback</i>-Phase, so kann das <i>rollback</i> aufgrund der Recoveryinformationen abgeschlossen und das <i>rollback</i> durch gef&#xfc;hrt werden. Informationen, um eine <i>rollback</i> abzuschliessen hei&#xdf;en, <i>rollback data</i>.</p>
<p>Befand sich das Persistenzsystem beim Abbruch bereits in der <i>committing phase</i>, so kann nat&#xfc;rlich nicht mehr <i>rollbacked</i> werden, (da typischerweise Ver&#xe4;nderungen w&#xe4;hrend des <i>commit</i> per Definition nicht mehr invertierbar sind), sondern das <i>commit</i> muss zu Ende gebracht werden. Es erfolgt ein sogenanntes <i>rollforward</i>. </p>
<p>Falls dazu Informationen notwendig sind, so m&#xfc;ssen diese am Beginn des <i>commit</i> protokolliert werden. Diese Informationen hei&#xdf;en <i>rollforward data</i>.</p>
<p>Folgende Grafiken zeigt, welche Informationen w&#xe4;hrend welchen Zustands bzw. w&#xe4;hrend welchen &#xdc;bergangs protokolliert werden k&#xf6;nnen.</p>
<p><img src="images/1PhaseCommitWithLogData.png" alt="1 phase commit with log data" /></p>
<p><i>Abbildung 4:</i> Zustands&#xfc;berg&#xe4;nge bei 1 Phase Commit inkl. Protokollierung der <i>rollback-/rollforward data</i></p>
<p><img src="images/2PhaseCommitWithLogData.png" alt="2 phase commit with log data" /></p>
<p><i>Abbildung 5:</i> Zustands&#xfc;berg&#xe4;nge bei 2 Phase Commit inkl. Protokollierung der <i>rollback-/rollforward data</i></p>
<p>Der Inhalt der Recoveryinformationen ist f&#xfc;r das Persistenzsystem spezifisch. Beim Recovery wird aus den Recoverinformationen der <i>transactional state</i> einer <i>connection</i> wiederhergestellt. Auf dem Zustand dieser <i>connection</i> kann die Ressource in einen korrekten Zustand &#xfc;berf&#xfc;hrt werden. Es darauf zu achten, dass die Charakteristika (rollback/rollforward) der Daten die zugrundeliegenden Aktionen widerspiegeln und die Daten der richtigen Phase zugeordnet werden. </p>
<p>Beim <i>2 phase commit</i> werden w&#xe4;hrend der <i>preparing phase</i> Aktionen ausgef&#xfc;hrt, die in einem nachgeordneten <i>rollback</i> explizit invertiert werden k&#xf6;nnen m&#xfc;ssen. Was passiert, wenn von den z.B. 3 Kommandos in der <i>preparing</i>-Phase die ersten 2 gelingen und das 3-te fehlschl&#xe4;gt? Da die ersten beiden i.d.R. den Zustand des Persistenzmediums ver&#xe4;ndert haben, m&#xfc;ssen sie explizit invertiert werden, um den Zustand vor dem <i>prepare</i> wiederherzustellen. Auf diesem setzt der Transaktionmanager bei seinen weiteren Bem&#xfc;hungen auf.</p>
<p>W&#xe4;hrend der <i>preparing phase</i> d&#xfc;rfen daher ebenfalls keine irreversiblen Aktionen durchgef&#xfc;hrt werden. Alle &#xc4;nderungen m&#xfc;ssen ebenfalls als <i>rollback data</i> protokolliert werden.</p>
<p>Wird die Transaktion w&#xe4;hrend der <i>committing phase</i> abgebrochen, muss ein <i>Recovery</i> w&#xe4;hrend eines Abbruchs die Transaktion zu Ende bringen und ein <i>commit</i> durchf&#xfc;hren. Dazu werden die <i>rollforward data</i> ben&#xf6;tigt. Diese m&#xfc;ssen <b>alle</b> Aktionen beschreiben, die f&#xfc;r das <i>rollforward</i> der Transaktion notwendig sind. Daher werden die <i>rollforward data</i> i.d.R. en block am Anfang der <i>committing phase</i> protokolliert.<br />Im Gegensatz dazu k&#xf6;nnen <i>rollback data</i> im allgemeinen einzeln und ohne R&#xfc;ck-/Vorgriff auf andere <i>rollback data</i> protokolliert werden. </p>
<p>Im Umkehrschluss folgt daraus, dass irreversible Aktionen nur in der <i>committing phase</i> zum Tragen kommen, denn ein Fehler/Abbruch w&#xe4;hrend dieser Phase f&#xfc;hrt beim Recovery zum <i>rollforward</i>.</p>
<div class="section">
<h3>Anforderung an Zustandsprotokollierung<a name="Anforderung_an_Zustandsprotokollierung"></a></h3>
<p>Die Recoveryinformationen m&#xfc;ssen bestimmte Bedingungen erf&#xfc;llen</p>

<ul>
  
<li><i>rollback data</i> m&#xfc;ssen Aktionen beschreiben, welche auf dem Persistenzmedium invertierbar sein.</li>
  
<li>Die Aktionen m&#xfc;ssen idempotent sein, d.h. eine mehrfache Ausf&#xfc;hrung der Invertierung muss immer zum selben Ergebnis im Persistenzsystem f&#xfc;hren. Dies ist wichtig, wenn beim <i>Recovery</i> Probleme auftreten und das <i>Recovery</i> eventuell wiederholt werden muss.</li>
  
<li>Die <i>committing phase</i> wird beim Recovery nicht invertiert, sondern zum vollst&#xe4;ndigen Abschluss gebracht ( <i>rollforward</i> ). Dabei ist ebenfalls zu ber&#xfc;cksichtigen, dass die Aktionen auch nur teilweise durchgef&#xfc;hrt wurden. Auch dies muss durch das Recoreyprotokoll unterst&#xfc;tzt werden.</li>
</ul></div>
<div class="section">
<h3>Anforderungen an eine Protokollierung<a name="Anforderungen_an_eine_Protokollierung"></a></h3>
<p>Sind die Inhalte des Recoveryprotokolls auch spezifisch f&#xfc;r jedes Persistenzsystem, so kann das Verfahren der Protokollierung selbst sehr wohl allgemein zur Verf&#xfc;gung gestellt werden. Es m&#xfc;ssen folgende Anforderungen an eine allgemeines Verfahren zur Protokollierung erf&#xfc;llt sein : </p>

<ol style="list-style-type: decimal">
  
<li>dauerhafte und atomare Protokollierung</li>
  
<li>performante, konkurrierende Protokollierung</li>
</ol>
<p>Punkt (1) ist eine Grundvorausetzung f&#xfc;r einen Protokollmechanismus. Die Daten m&#xfc;ssen einem sp&#xe4;teren <i>Recovery</i> zur Verf&#xfc;gung stehen und m&#xfc;ssen daher persistiert werden. Falls bei der Protokollierung Fehler auftreten, so f&#xfc;hrt dies zum Abbruch der Transaktion. Um das Protokoll konsistent und korrekt zu halten, muss das Schreiben des Protokolls atomar sein. Daten m&#xfc;ssen entweder ganz oder gar nicht geschrieben werden.</p>
<p><i>Phynixx</i> stellt ein solches Protokollierungsverfahren zur Verf&#xfc;gung, welches durch ResourceManager genutzt werden kann. Eine <i>connection</i> protokolliert ihre <i>rollforward/rollback data</i> &#xfc;ber ein definiertes Interface und <i>Phynixx</i> stellt sicher, dass die Informationen f&#xfc;r ein eventuelles Recovery bereit stehen. Der Inhalt und die Bedeutung der Protokolldaten unterscheiden sich wiederum zwischen den Persistenzsystem und daher muss das Recoveryprotokoll jeweils f&#xfc;r jedes Persistenzsysten spezifisch entworfen werden. </p>
<p>In Tutorial (siehe <a href="tutorial.html">Tutorial</a>) wird gezeigt, wie sequentielles Schreiben in eine Datei transaktional mit <i>Phynixx</i> unterst&#xfc;tzt wird. Insbesondere wird dort gezeigt, wie das Recoveryprotokoll f&#xfc;r diese Ressource aussieht und wie der allgemeine Protokollierungsmechanismus von <i>Phynixx</i> angesprochen wird.</p></div>
<div class="section">
<h3>Recorveryinformationen<a name="Recorveryinformationen"></a></h3>
<p>Eine XAResource wird zu einem Recoveryfall, wenn einer der folgenden Situationen eintritt</p>

<ul>
  
<li>Ressource verabschiedet sich undefiniert aus der Transaktion</li>
  
<li>Ausf&#xfc;hrungsthread/ -prozess stirbt wegen Verbindungverlust zu Servern (Datenbanken,..),Plattencrash, Stromausfall oder &#xe4;hnliche apokalyptische Szenarien</li>
  
<li>Transaktionsmanager verabschiedet sich undefiniert, weil Ausf&#xfc;hrungsthread/ -prozess stirbt. Gr&#xfc;nde k&#xf6;nnen auch hier Hardwarefehler wie Plattencrash, Stromausfall oder &#xe4;hnliche Szenarien sein. Insbesondere im Fall von verteilten Transaktionen kann der Transaktionmaneger in anderen Prozessen/Knoten ausgef&#xfc;hrt werden als die transaktionale Resource.</li>
</ul>
<p>Unabh&#xe4;ngig von dem Zustand (siehe <i>Abbildung 4/5</i>), in dem sich die Ressource beim Abbruch der Transaktion befunden hat, l&#xe4;&#xdf;t sich allein aus den Recoveryinformationen ableiten, was beim Recovery zu tun ist.</p>

<ol style="list-style-type: decimal">
  
<li>Falls <i>rollforward data</i> vorliegen, wird <i>rollforward</i> durchgef&#xfc;hrt. Eventuell vorhanden <i>rollback data</i> werden ignoriert.</li>
  
<li>Falls <i>rollback data</i> vorhanden sind, so wird ein <i>rollback</i> durch gef&#xfc;hrt.</li>
</ol></div>
<div class="section">
<h3>Integration in das Recoverykonzept des Transaktiomanagers ( nach JTA)<a name="Integration_in_das_Recoverykonzept_des_Transaktiomanagers__nach_JTA"></a></h3>
<p>coming soon</p>
<div class="section">
<h4>Registrierung von Resourcemanager<a name="Registrierung_von_Resourcemanager"></a></h4>

<ul>
  
<li>Serialisierung von XAResource</li>
</ul>
<p>coming soon</p></div></div></div>
<div class="section">
<h2>Integration in JTA<a name="Integration_in_JTA"></a></h2>
<div class="section">
<h3>Transaktionale Ressource<a name="Transaktionale_Ressource"></a></h3>
<p>Wie oben beschrieben, beinhaltet der transaktionale Zustand einer Ressource die Daten, welche durch ein <i>Commit/Rollback</i> betroffen sind. Dieser wird durch eine <i>connection</i> repr&#xe4;sentiert. Eine <i>XAResource</i> stellt die Verbindung einer Transaktion und einer <i>connection</i> her. Auf den ersten Augenschein sollte man meinen, dass eine <i>XAResource</i> h&#xf6;chstens eine <i>resource connection</i> besitzen kann, denn sie kann nicht an mehr als einer aktiven Transaktion teilnehmen.</p>
<p>Transaktionen k&#xf6;nnen allerdings unterbrochen (<i>suspend</i>) und zu einem sp&#xe4;teren Zeitpunkt wieder aktiviert (<i>resume</i>) werden.<br />Ist eine <i>XAResource</i> bereits an eine Transaktion gebunden und soll diese Ressource an einer weiteren Transaktion teilnehmen, so kann die bisherige Transaktion entweder beendet oder unterbrochen werden (<i>suspend</i>). In beiden F&#xe4;llen wird <i>XAResource.end()</i> (mit jeweils unterschiedlichen Parametern ) gerufen. Im Fall von <i>suspend</i> bleibt die dieser Transaktion zugeordnete <i>Connection</i> weiterhin bestehen. Eine <i>XAResource</i> muss also intern wissen, welche <i>connection</i> welcher Transaktion (identifiziert durch <i>XID</i>) zugeordnet ist. Die Verbindnung zwischen <i>connection</i> und Transaktion hei&#xdf;t <i>transational resource</i>.</p>
<p>Eine XAResource ordnet jeder <i>XID</i>, an der sie beteilig ist, die passende <i>connection</i> zu.</p>
<p>Das <i>Commit</i> auf der aktiven Transaktion darf nur die &#xc4;nderungen best&#xe4;tigen, die im Rahmen dieser Transaktion vorgenommen wurden. &#xc4;nderungen an <i>suspended</i> Transaktionen m&#xfc;ssen unbenommen bleiben. Daher muss die <i>XAResource</i> in diesem Fall zwei transaktionale Ressourcen unterst&#xfc;tzen.</p>
<p>Der einer XAResource zugeordnete transaktionale Kontext wird &#xfc;ber Transaktion (genauer die XID) qualifiziert. Mit den Angaben (XAResource, XID) wird die transaktionale Ressource qualifiziert. Es bedarf beider Angaben, um diese zu bestimmen.</p></div>
<div class="section">
<h3>Identifizierungen von ResourceManagern<a name="Identifizierungen_von_ResourceManagern"></a></h3>
<p>Falls sich zwei unterschiedliche Instanzen von <i>XAResource</i> des selben ResourceManagers an einer Transaktion beteiligen, so sollten deren transaktionale Zust&#xe4;nde zusammengefasst werden und sie sich ihre <i>connection</i> teilen. Um zu entscheiden, ob zwei <i>XAResource</i>-instanzen vom selben ResourceManager stammen, implementieren diese <i>XAResource.isSameRM()</i>. </p></div>
<div class="section">
<h3>Anforderungen an die Zuordnung von <i>XAResource</i> und transaktionalem Kontext<a name="Anforderungen_an_die_Zuordnung_von_XAResource_und_transaktionalem_Kontext"></a></h3>
<p>Entgegen ersten Eindr&#xfc;cken entspricht eine <i>XAResource</i> nicht immer genau einer <i>connection</i>. Folgende Situationen k&#xf6;nnen diese Zuordnungen beinflussen</p>

<ul>
  
<li>XAResource nimmt an einer zeitweilig stillgelegten Transaktion (<i>suspended</i>) und einer aktiven Transaktion teil.</li>
  
<li>In einer Transaktion werden unterschiedliche <i>XAResourcen</i> zu einem transaktionalen Kontext zusammengefasst. Falls die <i>XAResourcen</i> im Sinne von <i>isSameRM</i> gleich sind, so werden diese zusammengefasst (start(.., TMJOIN)</li>
</ul>
<p>Der transaktionale Zustand (==<i>connection</i>) entspricht pro Ressource der <i>XID</i>. Eine <i>XAResource</i> kann mehreren *XID*s zugeordnet sein und umgekehrt kann sich <i>XID</i> auf mehrere <i>XAResourcen</i> beziehen.</p>
<p>Der ResourceManager muss diese Beziehung im Hintergrund intern verwalten. Die jeweiligen Anl&#xe4;sse f&#xfc;r die Aktualisierungen dieser Zuorndungen werden durch den Transaktionmanager geliefert.</p></div>
<div class="section">
<h3>Lokale Transaktionen in JTA<a name="Lokale_Transaktionen_in_JTA"></a></h3>
<p>Gem&#xe4;&#xdf; <a class="externalLink" href="https://www.google.de/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;ved=0CDIQFjAA&amp;url=https%3A%2F%2Fjava.net%2Fprojects%2Fjta-spec%2Fsources%2Fspec-source-repository%2Fcontent%2Fjta-1_2-spec_v2.pdf%3Frev%3D14&amp;ei=J4IoU7ThJayv7Abx4IGgBg&amp;usg=AFQjCNHLwJXJjakdMcMhkWKl8MqIX7KJvA&amp;sig2=3jB0IV-PkKLUE1gWUwudOA&amp;bvm=bv.62922401,d.ZGU&amp;cad=rja" title="Spezifikation von JTA 1.2">JTA 1.2</a> Chap. 3.4.7 soll ein ResourceManager sowohl lokale als auch globale Transaktionen unterst&#xfc;tzen. W&#xe4;hrend lokale Transaktionen durch den Resourcemanager intern gestartet werden, werden globale Transaktionen durch einen Transaktionsmanager koordiniert, welcher mittels <i>XAResource</i> mit dem ResourceManager kommuniziert. F&#xfc;r die Koexistenz von lokalen und globalen Transaktionen gelten laut <a class="externalLink" href="https://www.google.de/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;ved=0CDIQFjAA&amp;url=https%3A%2F%2Fjava.net%2Fprojects%2Fjta-spec%2Fsources%2Fspec-source-repository%2Fcontent%2Fjta-1_2-spec_v2.pdf%3Frev%3D14&amp;ei=J4IoU7ThJayv7Abx4IGgBg&amp;usg=AFQjCNHLwJXJjakdMcMhkWKl8MqIX7KJvA&amp;sig2=3jB0IV-PkKLUE1gWUwudOA&amp;bvm=bv.62922401,d.ZGU&amp;cad=rja" title="Spezifikation von JTA 1.2">JTA 1.2</a> 3.4.7 folgende Anforderungen + Die lokale Transaktion muss abgeschlossen sein, bevor bzgl der gleichen <i>connection</i> eine globale Transaktion gestartet werden kann. + Die globale Transaktion muss von der <i>connection</i> getrennt sein, bevor eine lokale Transaktion ge&#xf6;ffnet sein darf.</p>
<p>Es ist Aufgabe des <i>ResourceManager</i>, jeweils zu entscheiden, ob die angeforderte <i>connection</i> an einer lokalen oder globalen Transaktion teilnimmt. Er hat die oben genannten Regeln f&#xfc;r die Koexistenz zu beachten. </p></div>
<div class="section">
<h3>Recovery in JTA<a name="Recovery_in_JTA"></a></h3>
<p>Der JTA-Recoveryprozess sieht vor, dass der TransaktionsManager die Resourcen nach Transaktionen befragt, die noch nicht abgeschlossen sind. </p>
<p>siehe <a class="externalLink" href="http://docs.oracle.com/cd/E12839_01/web.1111/e13731/jtatxexp.htm#WLJTA288" title="http://docs.oracle.com/cd/E12839_01/web.1111/e13731/jtatxexp.htm#WLJTA288">http://docs.oracle.com/cd/E12839_01/web.1111/e13731/jtatxexp.htm#WLJTA288</a></p>

<blockquote>
<p>When implementing XAResource.recover, you should use the flags as described in the X/Open XA specification as follows: + When the WebLogic Server transaction manager calls XAResource.recover with TMSTARTRSCAN, the resource returns the first batch of in-doubt Xids.</p>
  
<ul>
    
<li>
<p>The WebLogic Server transaction manager then calls XAResource.recover with TMNOFLAGS repeatedly, until the resource returns either null or a zero-length array to signal that there are no more Xids to recover. If the resource has already returned all the Xids in the previous XAResource.recover(TMSTARTRSCAN) call, then it can either return null or a zero-length array here, or it may also throw XAER_PROTO, to indicate that it has already finished and forgotten the previous recovery scan. A common XAResource.recover implementation problem is ignoring the flags or always returning the same set of Xids on XAResource.recover(TMNOFLAGS). This will cause the WebLogic Server transaction manager recovery to loop infinitely, and subsequently fail.</p></li>
    
<li>
<p>The WebLogic Server transaction manager XAResource.recover with TMENDRSCAN flag to end the recovery scan. The resource may return additional Xids.</p></li>
  </ul>
</blockquote>
<p>siehe auch [docs.jboss.org/jbosstm/5.0.0.M1/guides/failure_recovery_guide/ch02.html](docs.jboss.org/jbosstm/5.0.0.M1/guides/failure_recovery_guide/ ch02.html &#x201c;docs.jboss.org/jbosstm/5.0.0.M1/guides/failure_recovery_guide/ch02.html&#x201d;)</p>
<p>Insbesondere m&#xfc;ssen die Recoveryinformationen im Fall eine <i>2 phase commit</i>-Transaktion die aktuelle Transaktion (d.h. XID) kennen, um diese Beziehung wieder herstellen zu k&#xf6;nnen. </p>
<p>Die Spezifikation macht keine Aussagen &#xfc;ber der Recoveryprozess selbst oder &#xfc;ber Schnittstellen, diesen anzusprechen oder aufzurufen. Daher implementiert jeder JTA-Transaktionsmanager seinen eigenen Recoverymanager, der den Recoverproze&#xdf; steuert und ausf&#xfc;hrt. </p></div></div>
<div class="section">
<h2>Zuordnung zwischen <i>connection</i> und aktueller Transaktion<a name="Zuordnung_zwischen_connection_und_aktueller_Transaktion"></a></h2>
<p>Wird von zwei unterschiedlichen Punkten in der Anwendungslogik innerhalb einer Transaktion der <i>ResourceManager</i> nach einer <i>connection</i> gefragt, so ist zu erwarten, dass dieselbe <i>connection</i> geliefert wird. Innerhalb einer Transaktion sollte es bzgl. einer Ressource nur einen transaktionalen Zustand geben. Dies entspricht der Erwartungshaltung.</p>
<p>Um diese Erwartung zu erf&#xfc;llen, muss es eine Zuordnung zwischen <i>connection</i> und Transaktion bzgl. einer Resource geben.</p>
<p>Die Spezifikation sieht allerdings <b>nicht</b> vor, dass eine ResourceManager die Zuordnung der <i>connection</i> zur aktuellen Transaktion verwaltet. Dies resultiert aus der Ausrichtung der Spezifikation auf <a class="externalLink" href="https://java.net/downloads/connector-spec/connector-1_7-spec-final.pdf" title="JCA Connector Specification 1.7">JCA 1.7</a> und den Einsatz von ApplicationServern. In <a class="externalLink" href="https://java.net/downloads/connector-spec/connector-1_7-spec-final.pdf" title="JCA Connector Specification 1.7">JCA 1.7</a> wird die Zuordnung von <i>connection</i> und Transaktion durch den ApplicationServer vorgenommen und ist nicht Aufgabe des <i>ResourceManagers</i>. </p>
<p>Tats&#xe4;chlich bieten die g&#xe4;ngisten XAResource-Implementierungen (hsqldb, h2, mySql, Oracle) zwar die Zuordnung zwischen <i>connection</i> und <i>XAResource</i>, aber der <i>ResourceManager</i> (der in JDBC <i>XADataSource</i> hei&#xdf;t) liefert bei Nachfrage an eine <i>connection</i> jeweils eine neue <i>transactional resource</i> (neue Zuordnung zwischen Transaktion und <i>connection</i>). </p>
<p>Wird einer Resource aber in anderen Programmiermodellen wie z.B. Spring eingesetzt, so muss diese Aufgabe explizit gel&#xf6;st werden. </p>
<p>In Spring werden Transaktionen thread-bezogen ausgef&#xfc;hrt. Das Modell des <i>thread context</i> wird eingesetzt um den Scope (G&#xfc;ltigkeit/Sichtbarkeit) einer Transaktion zu definieren. Transaktionen sind nicht thread-&#xfc;bergreifend. Somit kann in Spring die Zuordnung zwischen <i>connection</i> und Transaktion erreicht werden, indem die beteiligten Ressourcen ihre aktuelle <i>connection</i> an den <i>thread context</i> heften. Spring bietet dazu M&#xf6;glichkeiten, sich in den Lebenszyklus von Transaktion einzuklinken und diese <i>connections</i> bei Start einer Transaktion zu aktualisieren bzw. bei deren Ende freizugeben. </p>
<p>Bei nicht-JTA-Transaktionsmangern (z.B. <i>DataSourceTransactionManager</i>) hat Spring diese L&#xf6;sung bereits umgesetzt und heftet die relevante JDBC-Connection an den aktuellen Thread. </p>
<p>In JTA-Transaktionen bietet Spring keinen derartige Unterst&#xfc;tzung. Jede Resource muss eigenst&#xe4;ndig umsetzen. In <a href="../spring-integration.md">Spring Integration</a> sind die Integrationsmechanismen und Szenarien zum gemeinsamen Einsatz von <i>Phynixx</i> und JDBC/JPA-basierten Ressourcen innerhalb einer Transaktion beschrieben.</p>
<p>Einige Implementierungen von Transaktionsmanagern bieten f&#xfc;r dieses Problem propriet&#xe4;re L&#xf6;sungen an (siehe <a href="spring-integration.md">Spring Integration</a> )</p>
<div class="section">
<h3>Aufgaben der Integration JTA<a name="Aufgaben_der_Integration_JTA"></a></h3>

<ul>
  
<li>Imnplementierung eines <i>XAResource</i></li>
  
<li>Managements der Zuordnung zwischen <i>XAResource</i> und <i>transaktionaler resource</i></li>
  
<li>Managements der Zuordnung zwischen <i>connection</i> und aktueller Transaktion</li>
  
<li>Teilnahme an lokalen und globalen Transaktionen</li>
  
<li>Unterst&#xfc;tzungen des Recoveryprotokolls in <a class="externalLink" href="https://www.google.de/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;ved=0CDIQFjAA&amp;url=https%3A%2F%2Fjava.net%2Fprojects%2Fjta-spec%2Fsources%2Fspec-source-repository%2Fcontent%2Fjta-1_2-spec_v2.pdf%3Frev%3D14&amp;ei=J4IoU7ThJayv7Abx4IGgBg&amp;usg=AFQjCNHLwJXJjakdMcMhkWKl8MqIX7KJvA&amp;sig2=3jB0IV-PkKLUE1gWUwudOA&amp;bvm=bv.62922401,d.ZGU&amp;cad=rja" title="Spezifikation von JTA 1.2">JTA 1.2</a></li>
  
<li>Integrationsszenarien mit Spring</li>
  
<li>Integrationsszenarien in JEE und JCA</li>
</ul>
<p><i>Phynixx</i> unterst&#xfc;tzt all diese Anforderungen vollst&#xe4;ndig. In <a href="tutorial.html">Tutorial</a> wird demonstriert, wie eine JTA-konforme Ressource entwickelt werden kann. Mehr Informationen zu Integrationsszenarien in <a href="spring-integration.md">Spring Integration</a> und zu <a href="jee-integration.md">JEE Integration</a>.</p>
</div></div>
<div class="section">
<h2>Unterst&#xfc;tzung von &#x2018;<i>Isolation</i>&#x2019;<a name="Untersttzung_von_Isolation"></a></h2>
<p>In Datenbanken wird das Konzept der &#x2018;<i>Isolation</i>&#x2019; durch komplexe Lock-mechanismen unterst&#xfc;tzt. Es werden unterschiedliche Level der Isolation und unterschiedliche Granularit&#xe4;ren des Lockings unterst&#xfc;tzt. Am Beispiel von Datenbanken (siehe [BERN et al] Chap 6) wird deutlich , welche Komplexit&#xe4;t Locking besitzt, so dass die Unterst&#xfc;tzung grundlegender Locking-Strategien oder gar ein allgemeiner Lock-Mechanismus den Umfang von <i>Phynixx</i> &#xfc;bersteigen w&#xfc;rde.</p>
<p><i>Phynixx</i> unterst&#xfc;tzt daher keinen allgemeinen Mechanismus zur Umsetzung von &#x2018;<i>Isolation</i>&#x2019;, so dass jede Ressource dieses Problem selbst l&#xf6;sen muss.</p>
<p>Im Tutorial (siehe <a href="tutorial.html">Tutorial</a>) wird beispielsweise f&#xfc;r sequentielles Schreiben in eine Datei der vergleichsweise einfache <i>Filelock</i> von Java als Locking-Mechanismus genutzt.</p>
<p>Falls die Entwicklung eines Lockingmechanismus f&#xfc;r eine Ressource zu aufwendig ist (oder evtl. nicht m&#xf6;glich ist), so bleibt das Konzept, den Zugriff auf die Daten der eigene Ressource durch Zugriffe auf relationale Datenbanken zu sch&#xfc;tzen und somit die Locking-Strategie von der eigenen Resource an die relationale Datenbank zu delegieren. </p>
<p>Die Granularit&#xe4;t der Zugriffe auf die eigene Daten wird durch entsprechenden Datens&#xe4;tze/Records der relationalen Datenbank abgebildet. Soll beispielsweise der Zugriff auf Dateien gesch&#xfc;tzt werden, so kann f&#xfc;r jede Datei ein Eintrag in der Datenbank existieren. Ein Zugriffschnittstelle stellt sicher, dass vor dem Zugriff auf die Datei erst der entsprechende Datensatz gelesen/gelockt wird. Ist sichergestellt, dass der Zugriff auf die Ressource nur &#xfc;ber diese Schnittstelle stattfindet, wird der Locking-Mechanismus an den Locking-mechanismus der Datenbank delegiert. Allerdings ergibt sich daraus, dass schreibende Zugriffe nicht in lokalen Transaktionen stattfinden, sondern immer JTA-Transaktionen erfordern (da immer auch eine Datenbank beteiligt ist). </p>

<ul>
  
<li>Granularit&#xe4;t des Locking wird durch Tabellenstrukturen der relationalen Datenbank vorgegeben, da das Locking auf Objekten der Datenbabnk geschieht.</li>
  
<li>Ver&#xe4;nderungen bedingen den Einsatz von JTA-Transaktionen, da sowohl Datenbank und als auch Ressource konsistent gehalten werden.</li>
  
<li>Zugriff auf die Ressource darf nur durch eine integrierende Schnittstelle stattfinden, da ansonsten der Locking-Mechnsimus augehebelt w&#xfc;rde.</li>
</ul>
<h1>Referenzen</h1>
<p><a class="externalLink" href="https://www.google.de/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;ved=0CDIQFjAA&amp;url=https%3A%2F%2Fjava.net%2Fprojects%2Fjta-spec%2Fsources%2Fspec-source-repository%2Fcontent%2Fjta-1_2-spec_v2.pdf%3Frev%3D14&amp;ei=J4IoU7ThJayv7Abx4IGgBg&amp;usg=AFQjCNHLwJXJjakdMcMhkWKl8MqIX7KJvA&amp;sig2=3jB0IV-PkKLUE1gWUwudOA&amp;bvm=bv.62922401,d.ZGU&amp;cad=rja" title="Spezifikation von JTA 1.2">JTA 1.2</a> : JTA 1.2 Spezification </p>
<p><a class="externalLink" href="http://www.opengroup.org/onlinepubs/009680699/toc.pdf" title="XA Specification">XA Spec</a> : XA Spoezifikation X/Open Ltd 1991</p>
<p><a class="externalLink" href="https://java.net/downloads/connector-spec/connector-1_7-spec-final.pdf" title="JCA Connector Specification 1.7">JCA 1.7</a> : JCA Connector Specification 1.7</p>
<p><a class="externalLink" href="http://www.datadirect.com/resources/resource-library/jdbc-developer-center/jdbc-tutorials/understanding-jta---the-java-transaction-api/distributed-transactions-and-the-transaction-manager" title="Unterstanding JTA">data_direct-2005</a> : Unterstanding JTA - Nur auf Basis der Begrifflichkeiten der JTA wie XAResource und XMID werden unterschieldliche Szenarien der Kommunikation zwischen TA-manager und XAresource demonstriert.</p>
<p><a class="externalLink" href="http://jroller.com/pyrasun/category/XA](http://jroller.com/pyrasun/category/XA" title="Umfangreiche und detailierte Diskussion der unterschiedlichen Szenarien eines XA Protokolls. XA Exposed Part I-III. Mike Spille (im Rahmen TheServerSide.com)">mike_spille-2004</a>: Umfangreiche und detailierte Diskussion der unterschiedlichen Szenarien eines XA Protokolls. XA Exposed Part I-III <a class="externalLink" href="http://jroller.com/pyrasun/category/XA"> http://jroller.com/pyrasun/category/XA</a>. Mike Spille (im Rahmen TheServerSide.com). 2004.</p>
<p><a class="externalLink" href="http://msdn.microsoft.com/en-us/library/ms687072%28v=vs.85%29.aspx">MSDN</a> : </p>
<p><a class="externalLink" href="http://dsl.serc.iisc.ernet.in/publications/thesis/rkg.ps.gz">gupta-1997</a> : Commit Processing in Distributed On-Line and Real-Time Transaction Processing Systems by Ramesh Kumar Gupta (Promotion am Indian Institute of Science , Bangalore). 1997. Grundlagen zu OLTP.</p>
<p><a class="externalLink" href="http://www.infoq.com/minibooks/JTDS">rich-2006</a> : Java Transaction Design Strategies by Mark Richards on May 14, 2006</p>
<p>[BERN et al] Principles of Transaction Processing, 2nd Edition By Philip A. Bernstein; Eric Newcomer Publisher: Morgan Kaufmann Pub. Date: July 24, 2009 Print ISBN-13: 978-1-55860-623-4</p>
<p><a class="externalLink" href="https://xadisk.java.net/">XADisk</a> : transactional access to existing file systems</p>
<p><a class="externalLink" href="https://blogs.oracle.com/fkieviet/entry/j2ee_jca_resource_adapters_the">FKIEVIET-1</a>: Spezielle Beobachtungen bei der Integration der XAresource in eine JCA Architektur</p>
<p><a class="externalLink" href="https://blogs.oracle.com/fkieviet/entry/j2ee_jca_resource_adapters_poisonous">FKIEVIET-2</a> : Akronyme rund um JCA</p></div>
                  </div>
            </div>
          </div>

    <hr/>

    <footer>
            <div class="container-fluid">
                      <div class="row-fluid">
                              <p >Copyright &copy;                   2015.
          All rights reserved.      
                    
      </p>
        </div>

        
        
                </div>
    </footer>
        </body>
</html>
