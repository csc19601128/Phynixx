<!DOCTYPE html>
<!--
 | Generated by Apache Maven Doxia at 2014-06-03 
 | Rendered using Apache Maven Fluido Skin 1.3.1
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="Date-Revision-yyyymmdd" content="20140603" />
    <meta http-equiv="Content-Language" content="en" />
    <title>phynixx-doc - </title>
    <link rel="stylesheet" href="./css/apache-maven-fluido-1.3.1.min.css" />
    <link rel="stylesheet" href="./css/site.css" />
    <link rel="stylesheet" href="./css/print.css" media="print" />

      
    <script type="text/javascript" src="./js/apache-maven-fluido-1.3.1.min.js"></script>

    
                  </head>
        <body class="topBarDisabled">
          
        
    
        <div class="container-fluid">
          <div id="banner">
        <div class="pull-left">
                                <div id="bannerLeft">
                <h2>Phynixx Doc.</h2>
                </div>
                      </div>
        <div class="pull-right">  </div>
        <div class="clear"><hr/></div>
      </div>

      <div id="breadcrumbs">
        <ul class="breadcrumb">
                
                    
                  <li id="publishDate">Last Published: 2014-06-03
                      <span class="divider">|</span>
                   </li>
                  <li id="projectVersion">Version: 2.0.0-SNAPSHOT
                      </li>
                      
                
                    
      
                            </ul>
      </div>

            
      <div class="row-fluid">
        <div id="leftColumn" class="span3">
          <div class="well sidebar-nav">
                
                    
                <ul class="nav nav-list">
                    <li class="nav-header">Phynixx</li>
                              
      <li>
  
                          <a href="project-info.html" title="Project Information">
          <i class="none"></i>
        Project Information</a>
            </li>
                              <li class="nav-header">Documentation</li>
                              
      <li>
  
                          <a href="getting-started.html" title="Getting Started">
          <i class="none"></i>
        Getting Started</a>
            </li>
                
      <li>
  
                          <a href="tutorial.html" title="Tutorial">
          <i class="none"></i>
        Tutorial</a>
            </li>
                
      <li>
  
                          <a href="background.html" title="Background">
          <i class="none"></i>
        Background</a>
            </li>
                
      <li>
  
                          <a href="references.html" title="Referenzen">
          <i class="none"></i>
        Referenzen</a>
            </li>
            </ul>
                
                    
                
          <hr />

           <div id="poweredBy">
                            <div class="clear"></div>
                            <div class="clear"></div>
                            <div class="clear"></div>
                            <div class="clear"></div>
                             <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy">
        <img class="builtBy" alt="Built by Maven" src="./images/logos/maven-feather.png" />
      </a>
                  </div>
          </div>
        </div>
        
                
        <div id="bodyColumn"  class="span9" >
                                  
            <h1>Transaktionen - kurz und knapp</h1>
<p>Eine transaktionale Ressource ist alles was an einer Transaktion teilnehmen kann, z.B. eine Datenbanverbindung , JMS-Conenction etc.</p>
<div class="section">
<h2>Lokale Transaktionen<a name="Lokale_Transaktionen"></a></h2>
<p>Falls sich Ihre Anwendung an mit einer transaktionalen Ressource verbindet, dort &#xc4;nderungen vor nimmt und diese dann mittels <i>commit</i> best&#xe4;tigt oder mit <i>rollback</i> verwirft, so spricht man von einer lokalen Transaktion. In diesem Fall bedarf es keine &#xfc;bergeordneten Koordination der Transaktion, den es ist nur eine Partei involviert.</p>
<p><img src="images/1PhaseCommit.png" alt="single phase commit" /></p>
<p><i>Abbildung 1:</i> Zustands&#xfc;berg&#xe4;nge bei 1 Phase Commit (nach [gupta-1997] Kap 3.2.1)</p></div>
<div class="section">
<h2>JTA Transaktionen<a name="JTA_Transaktionen"></a></h2>
<p>Nehmen mehr als eine transaktionale Ressource an der Transaktion teil, so reicht ein einfaches <i>rollback/commit</i>-Protokoll nicht mehr aus, sondern die Ressourcen m&#xfc;ssen koordiniert werden. dazu dient das <i>2 Phase Commit</i>-Protokoll. Dieses ist f&#xfc;r Java-Ressourcen in [JTA 1.2] beschrieben.</p></div>
<div class="section">
<h2>Verteilte Transaktionen<a name="Verteilte_Transaktionen"></a></h2>
<p>Nehmen auf unterschiedlechn System unterschiedliche transaktionale Ressourcen an der Transaktion teil, so spricht man von einer verteilten (<i>distributed</i>) Transaktion. Diese Situation stelle besondere Herausforderungen an den Transaktionsmanager, w&#xe4;hrend die transaktionale Ressource im wesentlichen das <i>2 Phase Commit</i>-Protokoll unterst&#xfc;tzen muss. daher werden wir auf verteilte Transaktionen nicht weiter eingehen.</p></div>
<div class="section">
<h2><i>2 Phase Commit</i>-Protokoll<a name="a2_Phase_Commit-Protokoll"></a></h2>
<p>Transaktionale Ressource, die ein <i>2 Phase Commit</i>-Protokoll unterst&#xfc;tzen, haben zwei Rollen zu spielen. Eine <i>Connection</i> ist das Objekt, gegen das die Anwendungslogik ausgef&#xfc;hrt wird. Der <i>ResourceManager</i> (oder auch <i>XAResource</i>) stellt die <i>Connection</i> bereit und sorgt daf&#xfc;r, das entsprechend der Regeln des <i>2 Phase Commit</i> die richtige <i>Connection</i> an der aktuellen Transaktion teilnimmt (siehe dazu [JTA 1.2]). Dabei sind folgende Situationen zul&#xe4;ssig</p>

<ul>
  
<li>eine XARResource nimmt mehreren Transaktionen teil</li>
  
<li>XAResource nimmt an einer zeitweilig stillgelegten Transaktion (<i>suspended</i>) und einer aktiven Transaktion teil.</li>
  
<li>In einer Transaktion werden unterschiedliche XAResourcen zu einem transaktionalen Kontext zusammengefasst werden. Falls die XAResourcen im Sinne von <i>isSameRM</i> gleich sind, so werden diese zusammen gefasst (start(.., TMJOIN)</li>
</ul>
<p>Grob gesprochen, gibt es pro Thread nur eine aktive Transaktion.</p>
<div class="section">
<h3>Protokoll<a name="Protokoll"></a></h3>
<p>W&#xe4;hrend der Phase, in der auf der <i>Connection</i> Anwendungslogik ausgef&#xfc;hrt wird und w&#xe4;hrend des <i>rollbacks</i> unterscheidet sich das <i>2 Phase Commit</i>-Protokoll nicht vom <i>Single Phase Commit</i>-Protokoll.</p>
<p>Das Commit verl&#xe4;uft dagegen in zwei Phasen. In der Phase <i>prepare</i> wird die Ressource von Transaktionsmanager gebeten, ein <i>Commit</i> vorzubereiten. Zu diesem zeitpunkt kann die Ressource gegen ein <i>Commit</i> stimmen und damit die gesamte Transaktion abbrechen lassen. Haben alle Ressourcen zugestimmt, so geibt es kein Zur&#xfc;ck und in der n&#xe4;chsten Phase fordert der Transaktionsmanager von aller Ressourcen ein <i>Commit</i> .</p></div>
<div class="section">
<h3>Transaktionaler Kontext<a name="Transaktionaler_Kontext"></a></h3>
<p>Transaktionaler Kontext (oder auch <i>transactional states</i>) beschreibt die Daten, welche durch eine <i>Commit/Rollback</i> auf einer XAResource betroffen sind. Auf den ersten Augenschein sollte man meinen, dass XAResource und transaktionaler Kontext sich entsprechend, aber tats&#xe4;chlich ist es so, dass eine XAResource mehrere transaktionale Kontexte unterst&#xfc;tzen kann.</p>
<p>Beispielsweise kann sie an einer <i>suspended</i> Transaktion und an einer aktiven Transaktion teilnehmen. Das <i>Commit</i> auf der aktiven Transaktion darf nur die &#xc4;nderungen best&#xe4;tigen, die im Rahmen dieser Transaktion vorgenommen wurden. &#xc4;nderungen der <i>suspended</i> Transaktion m&#xfc;ssen unbenommen bleiben. Daher muss die <i>XAResource</i> in diesem Fall zwei transaktionale Kontext unterst&#xfc;tzen.</p>
<p>Der einer XAResource zugeordnete transaktionale Kontext wird &#xfc;ber Transaktion (genauer die XID) qualifiziert. Mit den Angaben (XAResource, XID) wird der transaktionale Kontext qualifiziert. Es ben&#xf6;tigt beide Angaben, um ihn zu bestimmen.</p>
<p>Eine XAResource wird durch einen Transaktion-ID identifiziert, die sogenannte <i>XID</i>. Diese wird durch den Transaktionsmanager der XAResource &#xfc;bergeben, wenn diese eine <i>Connection</i> bereitstellen soll. Vereinfacht gesprochen entspricht pro XARessource jede <i>XID</i> einem transaktionalen Kontext.</p>
<p>Technologischer Kontext Transaktionssteuerung Zustands&#xfc;berg&#xe4;nge einer TA-gesicherten Resource In [gupta-1997] Kap 3.2.1 sind die Zustands&#xfc;berg&#xe4;nge einer transaktionsgesicherten Ressource in einem <i>2 phase commit</i>-Protokoll beschrieben. (Abort(ing) entspricht dem g&#xe4;ngigeren rollback(-ing).) Bzgl. des 1 phase commit protocols lassen diese wie inAbbildung 1 reduzieren.</p>
<p><img src="images/2PhaseCommit.png" alt="two phase commit" /></p>
<p><i>Abbildung 2:</i> Zustands&#xfc;berg&#xe4;nge bei 2 Phase Commit (nach [gupta-1997] Kap 3.2.1)</p></div></div>
<div class="section">
<h2>Lokale Transaktionen<a name="Lokale_Transaktionen"></a></h2>
<p>siehe [JTA 1.1] Chap. 3.4.7 The resource adapter is encouraged to support the usage of both local and global transactions within the same transactional connection. Local transactions are transactions that are started and coordinated by the resource manager internally. The XAResource interface is not used for local transactions. When using the same connection to perform both local and global transactions, the following rules apply: &#x2022; The local transaction must be committed (or rolled back) before starting a global transaction in the connection. &#x2022; The global transaction must be disassociated from the connection before any local transaction is started. If a resource adapter does not support mixing local and global transactions within the same connection, the resource adapter should throw the resource specific exception. For example, java.sql.SQLException is thrown to the 22 application if the resource manager for the underlying RDBMS does not support mixing local and global transactions within the same JDBC connection.</p></div>
<div class="section">
<h2>1x1 der Transaktionen<a name="a1x1_der_Transaktionen"></a></h2>
<p>Transaktion lokale Transaktion 2 Phase Commit distributed transaction Transaktionmanager transactionale Ressource XARessource</p>

<table border="0" class="table table-striped">

<tr class="a">
<th></th>
<th></th> </tr>

<tr class="b">
<td>transaktionale Ressource</td> 
<td>Jede </td> </tr>

<tr class="a">
<td>lokale Transaktion</td> 
<td>Transaktion, die direkt auf der tr</td></tr>

<tr class="b">
<td>XA-Transaktion</td> 
<td>verteilte oder auch 2 Phase Commit Transaktion; Transaktion, an der mehr als eine transaktionale Ressourece teilnimmt</td> </tr>

<tr class="a">
<td>Transaktionsmanager</td> 
<td>Koordiniert eine Transaktion</td> </tr>

<tr class="b">
<td></td> 
<td></td> </tr>

<tr class="a">
<td></td> 
<td></td> </tr>

<tr class="b">
<td></td> 
<td></td> </tr>
</table>
<p>Diese beiden Zustands&#xfc;bergange sind Grundlage f&#xfc;r die weiteren Diskussionen.</p></div>
<div class="section">
<h2>Persistenzsysteme<a name="Persistenzsysteme"></a></h2>
<p>Persistenzsysteme ohne eigene Transaktionssematik (Filesysteme, einige Archivsysteme (centera)) m&#xfc;ssen bei ihrer Einbettung in eine Transaktionssystem unterst&#xfc;tzt werden. Die Informationen, um ggf. rollback durchf&#xfc;hren zu k&#xf6;nnen, m&#xfc;ssen au&#xdf;erhalb des Peristenzsystems protokolliert werden. Bzgl. der ben&#xf6;tigten Informationen zur Durchf&#xfc;hrung eines rollbacks k&#xf6;nnen 3 Systeme unterschieden werden - Persistenzsysteme mit Transaktionssemantik (Datenbanken, JMS) - Persistenzsysteme, bei denen zum <i>Rollback</i> Zustandsinformationen zu Beginn der TX reichen (z.B. sequentielle Schreiben in Dateien) - Persistenzsysteme, bei denen die einzelnen Ver&#xe4;nderungen des Systems protokolliert werden und im &#x2018;Rollback&#x2019;-Fall einzeln und in umgekehrter Reihenfolgen zur&#xfc;ckgesetzt werden m&#xfc;ssen (z.B.Archivsysteme wie Centera, Filesysteme) (Kompensationsverfahren)</p>
<p>Bei Typ 2/3 m&#xfc;ssen die notwendigen Informationen (im weiteren LogRecord) protokolliert werden. Bevor ein zustandsver&#xe4;nderde Aktion ausgef&#xfc;hrt wird, werden ausreichende Informationen protokolliert, um diese Aktion invertieren/kompensieren zu k&#xf6;nnen. Diese Informationen werden beim <i>rollback</i> oder beim _recovery _ oder Transaktion nutzt. Diese Daten heissen <i>rollback data</i>.</p></div>
<div class="section">
<h2>Recovery<a name="Recovery"></a></h2>
<p>Recovery ist dann notwendig, wenn die Transaktionssteuerung w&#xe4;hrend der Transaktion abbricht und das Persistenzsystem in einem undefinierten Zustand zur&#xfc;ckl&#xe4;&#xdf;t. In diesem Fall m&#xfc;ssen die LogRecords restauriert werden und auf Basis dieser LogRecords das Persistenzsystem in einen in einen konsistenten Zustand &#xfc;berf&#xfc;hrt werden. Befand sich das Persistenzsystem beim Abbruch bereits in der committing phase, so kann nat&#xfc;rlich nicht mehr rollbacked werden, (da typischer Weise Ver&#xe4;nderungen w&#xe4;hrend des commit per Definition nicht mehr invertierbar sind,) sondern das <i>commit</i> muss zu Ende gebracht werden. Es erfolgt ein sogenanntes rollforward. </p>
<p>Falls dazu Informationen notwendig sind, so m&#xfc;ssen diese am Beginn des <i>commits</i> protokolliert werden. Diese Informationen hei&#xdf;en <i>rollforward data</i>. &#160;</p>
<div class="section">
<h3>Anforderung an Zustandsprotokollierung<a name="Anforderung_an_Zustandsprotokollierung"></a></h3>
<p>Die unterschiedlichen Zust&#xe4;nde und die in den Zust&#xe4;nden/Zustands&#xfc;berg&#xe4;ngen erzeugten Steuerungsinformationen werden in LogRecord abgelegt. An dieser Stelle wird nichts &#xfc;ber das Verfahren zur der Protokollierung der LogRecord ausgesagt. Diese LogRecords m&#xfc;ssen bestimmte Bedingungen erf&#xfc;llen</p>

<ul>
  
<li>Die Aktionen m&#xfc;ssen auf dem Persistenzmedium invertierbar sein. Ausnahme sind Aktionen, die durch <i>rollforward data</i> definiert werden..</li>
  
<li>Bei Archivsystemen ist es z.B. nicht ohne weiteres m&#xf6;glich, Eintr&#xe4;ge zu ver&#xe4;ndern. Das macht ja gerade ein revisionssicheres Archivsystem aus. Ist dem Eintrag eine Verweildauer zugewiesen, w&#xe4;hrend derer nicht ver&#xe4;ndert werden darf, so ist diese Aktion nicht mehr invertierbar. Eine solche Information geh&#xf6;rt typischerweise zu <i>rollforward data</i></li>
  
<li>Die Aktionen m&#xfc;ssen idempotent sein, d.h. eine mehrfache Ausf&#xfc;hrung der Invertierung muss immer zum selben Ergebnis im Persistenzsystem f&#xfc;hren. Dies ist wichtig, wenn beim <i>recovery</i> Probleme auftreten und das <i>recovery</i> eventuell wiederholt werden muss. Auch falls die Aktion loggt wurde, kann sie gar nicht oder nur teilweise durchgef&#xfc;hrt worden sein. Auch in diesem Fall muss das Recovery gelingen und den Zustand vor Schreiben des LogRecords wiederherstellen.</li>
  
<li>Die committing phase wird beim Recovery nicht invertiert, sondern zum vollst&#xe4;ndigen Abschluss gebracht ( roll forward ). LogRecords und zugrunde liegende Aktionen dieser Phase m&#xfc;ssen dies unterst&#xfc;tzen. Dabei ist ebenfalls zu ber&#xfc;cksichtigen, dass die Aktionen auch nur teilweise durchgef&#xfc;hrt wurden.</li>
</ul>
<p>Beim 2 phase commit werden w&#xe4;hrend der _preparing phase _Aktionen ausgef&#xfc;hrt, die in einem nachgeordneten rollback explizit invertiert werden m&#xfc;ssen. Was passiert, wenn von den z.B. 3 Kommandos in der preparing -Phase die ersten 2 gelingen und das 3-te fehlschl&#xe4;gt? Da die ersten beiden i.d.R. den Zustand des Persistenzmediums ver&#xe4;ndert haben, m&#xfc;ssen sie explizit invertiert werden, um den Zustand vor dem prepare wiederherzustellen. Auf diesem setzt der Transaktionmanager bei seinen weiteren Bem&#xfc;hungen auf. Dies ist aber m&#xf6;glich, da w&#xe4;hrend preparing keine irreversiblen Aktionen durchgef&#xfc;hrt werden. W&#xe4;hrend der prepare phase werden also ebenfalls einzelne rollback LogRecords protokolliert.</p>
<p>&#xdc;bel ergeht es dem Persistenzsystem, wenn w&#xe4;hrend der committing phase abgebrochen wurde. Da es kein Zur&#xfc;ck gibt, muss ein recovery w&#xe4;hrend eines Abbruchs in der committing phase die TX zu Ende bringen. Dazu m&#xfc;ssen aber die ben&#xf6;tigten Informationen zur Verf&#xfc;gung stehen. Diese mussten also vor dem Abbruch en block protokolliert worden sein.</p>
<p>Im Gegensatz zu rollback data , die einzelne protokolliert werden k&#xf6;nnen, werden rollforward LogRecords en block vor Beginn der commtting phase protokolliert. Falls der Fortschritt des commits protokolliert werden muss, um ein recorvery steuern zu k&#xf6;nnen (bis wohin ist das commit tats&#xe4;chlich bereits ausgef&#xfc;hrt worden?) sind evtl. so genannte rollforward status LogRecords protokolliert.</p>
<p>Im Umkehrschluss folgt daraus, dass irreversible Aktionen nur in der committing phase zum Tragen kommen, denn ein Fehler/Abbruch w&#xe4;hrend dieser Phase f&#xfc;hrt beim recovery zum roll forward .</p></div>
<div class="section">
<h3>Last Resource Gambit<a name="Last_Resource_Gambit"></a></h3>
<p>In vielen F&#xe4;llen kann man sich mit dem so genannten mit dem Verfahren helfen, das in the Last Resource Gambit bezeichnet wird. Die Transaktionssteuerung wei&#xdf; um die einzelnen Charakteristika der Persistenzsysteme und stellt ihre Verarbeitungslogik darauf ein.</p>
<p>Ist z.B. nur ein nicht XA-kompatible Persistenzmedium an der Transaktion beteiltigt, so wird nachdem prepare an alle anderen beteiligten Resourcen das commit der Nicht-kompatiblen gerufen und anschlie&#xdf;end das commit der XA-Resourcen. Dieses Verfahren l&#xf6;st zwar auch nicht das oben beschrieben Problem der irreversiblen Aktionen, die w&#xe4;hrend des prepare-Phase fehlschlagen, aber dasjenige des rollbacks nach erfolgreicher prepare-Phase.</p></div>
<div class="section">
<h3>Logging in presumed abort Algorithmus<a name="Logging_in_presumed_abort_Algorithmus"></a></h3>
<p>Der presumed abort - Algorithmus ist in [gupta-1997] definiert.</p>

<blockquote>
<p>&#x201e;&#x2026; , the 2PC protocol requires transmission of several messages and force-writing of several log records. A variant of the 2PC protocol, called presumed abort (PA), attempts to reduce these overheads by requiring all cohorts to follow a &#x201c;in the no information case, abort&#x201d; rule.&#x201c;</p>
</blockquote>
<p>presumed abort bedeutet als Konsequenz, dass der Transaktionmanager die Transaktion nur vor und w&#xe4;hrend der eigenlichen committing phase ( prepare,commit ) protokollieren muss. Insbesondere m&#xfc;ssen weder rollback-Records noch Informationen vor der committing phase geloggt werden. Es werden ebenfalls keine Informationen f&#xfc;r TX geloggt, die zu 1PC optimiert wurden.</p>
<p>Dieses Verfahren setzt im Falle eines Abbruchs voraus, dass alle eingesetzten ResourceManager in der Lage sind, ihre Resourcen zu restaurieren (recover). Der TM &#xfc;bernimmt nur eine Koordination der abgebrochenen TX, wenn diese w&#xe4;hrend der committing phase ( 2PC mit prepare/commit) abgebrochen ist.</p>
<p>Ein Logging-Verfahren, dass diese Eigenschaft unterst&#xfc;tzt, hat im wesentliche folgende Funktionalit&#xe4;t. 1. Bevor ein Commit-gestartet wird, werden alle beteiligten XAResourcen geloggt, so dass diese beim Wiederanlauf referenzierbar sind. 2. Es werden keinerlei inhaltliche Informationen &#xfc;ber den XAResourcen durch den TM geloggt. Diese ist Aufgabe des RM. 3. Falls die commiting phase erfolgreich abgeschlossen wird, so sind die log-Informationen (siehe 1) unn&#xf6;tigt und k&#xf6;nnten gel&#xf6;scht werden 4. Falls der TM w&#xe4;hrend der commiting phase abst&#xfc;rtzt, so kann auf Basis der commit-Logs die Situation zum Zeitpunkt das Abbruchs wiederhergestellt werden. Dies allerdings nur aus Sicht des TMs (siehe unten). 5. XAResourcen m&#xfc;ssen ihre TX-Informationen, die zur Integration in die TX notwendigen Informationen wie XID) erst ab der prepare-Phase loggen. Zuvor allerdings m&#xfc;ssen evtl. Informationen f&#xfc;r recovery/rollback geloggt werden. 6. Wiederherstellung einer XAResource umfasst auch die Informationen, um die Referenz des TM auf diese XAResource (siehe 1) aufzul&#xf6;sen. Dazu ist in der Regel zu untersuchen, wie der gew&#xe4;hlte TM die XAResource referenziert (z.B. via toString() wie JOTM). 7. XAResource.recover() liefert alle wiederherstellbaren XAResources des RM. Dabei k&#xf6;nnen diejenigen, die nicht an wiederherstellbaren TX beteiligt sind, ignoriert werden.</p>
<p>Ein Logging-Verfahren, dass diese Eigenschaft unterst&#xfc;tzt, hat im wesentliche folgende Funktionalit&#xe4;t.</p>

<ol style="list-style-type: decimal">
  
<li>performantes, konkurriendes Logging (selbstverst&#xe4;ndlich)</li>
  
<li>dauerhaftes und atomares Logging</li>
  
<li>B&#xfc;ndelung der Records der committing phase , nur ein I/O-Zugriff pro Start einer committing phase</li>
  
<li>Ignorierung/L&#xf6;schen/&#xdc;berscheiben von Logrecords, die zu erfolgreich abgeschlossenene TX geh&#xf6;ren. Diese sollen im Log keinen Platz blockieren (garbage collection f&#xfc;r LogRecords).</li>
</ol>
<p>Ein hinsichtlich dieser Anforderungen optimiertes Loggingsystem ist offensichtlich nicht optimiert, recovery/rollback -Informationen f&#xfc;r eine XAResource zu unterst&#xfc;tzen. Dort muss die B&#xfc;ndelung nicht auf Basis der Records der Committing Phase sondern bzgl. aller w&#xe4;hrend einer TX angefallenen Daten geschehen. ist die TX abgeschlossen, so sind diese geb&#xfc;ndelten Records freizugeben. Rollback- / Recorveryinformationen</p>
<p>In [mike_spille-2004] sind Szenerien f&#xfc;r Recovery aus Sicht eines Transaktionsmanagers durchgespielt. Aus Sicht einer XAResource sind andere Szenarien zu betrachten und andere L&#xf6;sungsans&#xe4;tze zu untersuchen. Eine XAResource wird zu einem Recoveryfall, wenn einer der folgenden Situationen eintritt</p>

<ul>
  
<li>XAResource verabschiedet sich undefiniert aus der TX</li>
  
<li>Ausf&#xfc;hrungsthread/ -prozess stirbt wegen Verbindungverlust zu Servern (Datenbanken,..),Plattencrash, Stromausfall oder &#xe4;hnliche apokalyptische Szenarien</li>
  
<li>Transaktionsmanager verabschiedet sich undefiniert, weil Ausf&#xfc;hrungsthread/ -prozess stirbt. Gr&#xfc;nde k&#xf6;nnen auch hier Hardwarefehler wie Plattencrash, Stromausfall oder &#xe4;hnliche Szenarien sein</li>
</ul>
<p>Recovery im Umfeld von XA hat zwei unterschiedlichen Aspekte.</p>
<p>Zum ersten muss das Persistenzsystem wiederhergestellt werden. Dieser Vorgang ist unabh&#xe4;ngig von der Beteiligung der Resource an einer DTX.</p>
<p>Falls das Persistenzsystem an einer DTX beteiligt war und die Beteiligung wieder reaktiviert werden muss (nur Zustand prepared ), so hat sich das restaurierte Persistenzsystem beim Transaktionsmanager f&#xfc;r die entsprechende DTX anzumelden. F&#xfc;r den Transaktionsmanager ist eine XAResource nur dann beim recovery interessant, wenn diese an einer TX teilgenommen hat, deren prepared+committing phase wiederhergestellt wird. Ansonsten wei&#xdf; der Transaktionmanager (siehe presumed abort ) nichts &#xfc;ber die XAResource und diese kann sich isoliert wiederherstellen und ein <i>rollback</i> durchf&#xfc;hren.</p>
<p>Falls diese w&#xe4;hrend der executing oder preparing phase stecken geblieben ist, so hat der recovery Mechanismus des Resourcemanagers f&#xfc;r ein korrekte Wiederherstellung des Persistenzsystems zu sorgen. Wie kann also ein Verfahren aussehen, welches f&#xfc;r eine Ressource einerseits WAL unterst&#xfc;tzt, andererseits die Zust&#xe4;nde bzgl. einer 2PC-TX und 1 PC-TX protokolliert.</p>
<p>Es scheint sinnvoll, nur ein einziges logging Verfahren zu etablieren und f&#xfc;r die unterschiedlichen Zwecke verschiedene Verfahren aufzusetzen. In [gupta-1997] Kap 3.2.1 sind die Zustands&#xfc;berg&#xe4;nge einer XAResource in einem 2PC Protokoll beschrieben. F&#xfc;r ein Recovery ist es grunds&#xe4;tzlich ausreichend, die Zust&#xe4;nde preparing , prepared, committing und aborting zu sichern. Implizit l&#xe4;&#xdf;t daraus der Zustand executing ableiten. Kenntnisse des Zustands der XAResource und die LogRecords versetzen die XAResource in die Lage, sich zu restaurieren.</p>
<p>Beim Ausgangszustand committing oder aborting kann es nat&#xfc;rlich sein (es ist sogar die Regel) , dass nichts zu tun ist, um die XAResource wiederherzustellen, da die Aktionen korrekt abgeschlossen wurden. Dies kann nur festgestellt werden, wenn der Abschlu&#xdf; der TX durch einen done-Record markiert wird. Anhand des Endezustands kann der Recoverymanager erkennen, dass kein Recovery notwendig ist und das Loggingsystem, dass LogRecords solcher XAResourcen vergessen werden k&#xf6;nnen. Der Ausgangszustand committing (ohne abschliessendes done) bedingt ein roll forward . Der Ausgangszustand aborting bedingt ein rollback . Unter Annahme, dass &#x2018;keine Informationen&#x2019; mitabort gleichzusetzen sind (presumed abort ), ist der Zustand aborting nicht explizit zu protokollieren, sondern wird wie der Ausgangszustand executing behandelt. Gleiches gilt f&#xfc;r preparing . Daraus ergibt sich, dass die Zust&#xe4;nde prepared, committing und done protokolliert werden. Mit den Zust&#xe4;nden m&#xfc;ssen auch immer alle Informationen geloggt werden, die notwendig sind, die avisierten Zustand&#xfc;berg&#xe4;nge auch durchzuf&#xfc;hren. Die XAResource muss auch beachten, dass die Zustands&#xfc;berg&#xe4;nge bereits teilweise durchgef&#xfc;hrt sind. Sie muss dies erkennen k&#xf6;nnen und ad&#xe4;quat darauf reagieren.</p>
<p>Bricht die XAResource w&#xe4;hrend executing oder preparing ab, so ist keiner der obigen Zust&#xe4;nde protokolliert. Was zu tun w&#xe4;re, ist klar. Falls die XAResource w&#xe4;hrend der executing phase abgebrochen ist, so ist eine rollback durch zuf&#xfc;hren. Ist sie dagegen w&#xe4;hrend der preparing phase abgebrochen, ist zu erwarten, dass die XAResource untersucht, ob es eine wiederhergestellte, globale DTX gibt, an der sie teilnehmen kann. Die XAResource wird dieser &#xfc;bergeben, allerdings im Zustand MARK_ROLLBACK. Dadurch ist gew&#xe4;hrleistet, dass alle an der TX beteiligten XAResourcen rollbacked werden. Da allerdings bei Transaktionmanagern die den Recoveryprozess gem&#xe4;&#xdf; presumed abort unterst&#xfc;tzen, globale Transaktionen, welche in der preparing phase abbrechen, nicht als recoverable protokollieren, ist es nicht notwendig, die aufwendige Sonderbehandlung f&#xfc;r die Fall vorzusehen. Auch in diesem Fall kann also der Recoverymanager des XAResource ein rollback durchf&#xfc;hren. Insbesondere wird der Zustand preparing nicht protokolliert.</p>
<p>Um all die Zustandsinformationen einer TX zuordnen zu k&#xf6;nnen, muss beim Beginn der Beteiligung der XAResource an der TX (Eintritt in executing ) protokolliert werden, mit welcher Identit&#xe4;t die XAResource an welcher TX ( identifiziert durch XID) teilnimmt. Dieser TX-Informationen m&#xfc;ssen auch allen weiteren LogRecords zugeordnet sein, die sich auf diese XAResource innerhalb dieser TX beziehen. St&#xf6;&#xdf;t der Recoverymanager auf eine XAResource eines solchen Zustands, so zeigt folgende Tabelle, wie zu reagieren ist:</p>

<table border="0" class="table table-striped">

<tr class="a">
<td>erster Satz bei XAResource (nur bei XAResource bei Beteiligung an 2PC)</td>
<td>Um die XAResource der TX zuzuordnen, sind aus dem erstem LogRecord sowohl Identit&#xe4;t der XAResource (zur Registrierung beim Transaktionsmanager) und XID zu ermitteln.</td></tr>

<tr class="b">
<td>Prepared</td>
<td>Da XAResource f&#xfc;r den Transaktionsmanager in Bezug auf recovery nur nur im Zustand prepared / committing interessant sind, muss sich die XAResource an den TX der wiederhergestellten globalen TX beteiligen , um den TransaKtionsmanager die TX geordnet abzuschliessen.</td></tr>

<tr class="a">
<td>committing</td>
<td>Nimmt die XAResource am 2PC teil, so siehe prepared . Ansonsten wird das commit vollst&#xe4;ndig zu Ende gef&#xfc;hrt.</td></tr>

<tr class="b">
<td>keiner der obigen Zust&#xe4;nde</td>
<td>XAResource f&#xfc;hrt abschliessende Arbeiten aus, um dass rollback/abort abzuschliessen. Es ist keine globale TX notwendig, innerhalb derer die XAResource rollbacked werden muss.</td></tr>
</table>
<p>Folgende Grafik zeigt welche Informationen w&#xe4;hrend welches Zustands bzw. w&#xe4;hrend welches &#xdc;bergangs protokolliert werden k&#xf6;nnen.</p>
<p><img src="images/1PhaseCommitWithLogData.png" alt="1 phase commit with log data" /></p>
<p><i>Abbildung 3:</i> Zustands&#xfc;berg&#xe4;nge bei 1 Phase Commit inkl. Logging der <i>rollback-/rollforward data</i></p>
<p><img src="images/2PhaseCommitWithLogData.png" alt="2 phase commit with log data" /></p>
<p><i>Abbildung 4:</i> Zustands&#xfc;berg&#xe4;nge bei 2 Phase Commit inkl. Logging der <i>rollback-/rollforward data</i></p></div></div>
                  </div>
            </div>
          </div>

    <hr/>

    <footer>
            <div class="container-fluid">
                      <div class="row-fluid">
                              <p >Copyright &copy;                   2014.
          All rights reserved.      
                    
      </p>
        </div>

        
        
                </div>
    </footer>
        </body>
</html>
