<!DOCTYPE html>
<!--
 | Generated by Apache Maven Doxia at 2014-03-09 
 | Rendered using Apache Maven Fluido Skin 1.3.1
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="Date-Revision-yyyymmdd" content="20140309" />
    <meta http-equiv="Content-Language" content="en" />
    <title>phynixx-doc - </title>
    <link rel="stylesheet" href="./css/apache-maven-fluido-1.3.1.min.css" />
    <link rel="stylesheet" href="./css/site.css" />
    <link rel="stylesheet" href="./css/print.css" media="print" />

      
    <script type="text/javascript" src="./js/apache-maven-fluido-1.3.1.min.js"></script>

    
                  </head>
        <body class="topBarDisabled">
          
        
    
        <div class="container-fluid">
          <div id="banner">
        <div class="pull-left">
                                <div id="bannerLeft">
                <h2>phynixx-doc</h2>
                </div>
                      </div>
        <div class="pull-right">  </div>
        <div class="clear"><hr/></div>
      </div>

      <div id="breadcrumbs">
        <ul class="breadcrumb">
                
                    
                  <li id="publishDate">Last Published: 2014-03-09
                      <span class="divider">|</span>
                   </li>
                  <li id="projectVersion">Version: 2.0.0-SNAPSHOT
                      </li>
                      
                
                    
      
                            </ul>
      </div>

            
      <div class="row-fluid">
        <div id="leftColumn" class="span3">
          <div class="well sidebar-nav">
                
                    
                <ul class="nav nav-list">
                    <li class="nav-header">Documentation</li>
                              
      <li>
  
                          <a href="getting-started.html" title="Getting Started">
          <i class="none"></i>
        Getting Started</a>
            </li>
                
      <li class="active">
  
            <a href="#"><i class="none"></i>Tutorial</a>
          </li>
            </ul>
                
                    
                
          <hr />

           <div id="poweredBy">
                            <div class="clear"></div>
                            <div class="clear"></div>
                            <div class="clear"></div>
                            <div class="clear"></div>
                             <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy">
        <img class="builtBy" alt="Built by Maven" src="./images/logos/maven-feather.png" />
      </a>
                  </div>
          </div>
        </div>
        
                
        <div id="bodyColumn"  class="span9" >
                                  
            <h1>Tutorial</h1>
<p>SourceCode findet sich im Module <i>phynixx-tutorial</i>. </p>
<p>Das Projekt Phynixx bietet eine einfache M&#xf6;glichkeit f&#xfc;r Ressourcen an Transaktionen teilnehmen zu nehmen, seien es lokale oder globale (XA-protokoll, 2PC-) Transaktionen. Um eine Vorstellung vom Programmiermodell zu erhalten, stellen Sie sich einer herk&#xf6;mmliche Datenbankverbindung <tt>javax.sql.Connection</tt> vor. Diese Verbindung ist transaktional und kann, je nach zu grundeliegender DatenSource, auch an XA-Transaktionen teilnehmen.<br />Neben der <i>Connection</i> ist die <i>DateSource</i> in ihrer Rolle als <i>ConnectionFactory</i> wichtig. </p>
<p>Auch im Programmiermodell von Phynixx wird ihre transaktionale Ressource als Connection bezeichnet, ebenso existiert eine ConnectionFactory um die Connections zu erzeugen. </p>
<div class="section">
<h2>Fahrplan des Tutorials<a name="Fahrplan_des_Tutorials"></a></h2>
<p>In diesem Tutorial wird beschrieben, welche Voraussetzungen geschaffen werden m&#xfc;ssen, dass eine Ressource am Transaktionsprotokoll teilnehmen kann. Als Beispiel dient sequentielles Schreiben in eine Datei. Dies soll transaktional unterst&#xfc;tzt werden und solwohl in an lokalen als auch globalen Transaktionen teilnehmen k&#xf6;nnen.</p></div>
<div class="section">
<h2>Beispiel<a name="Beispiel"></a></h2>
<p>In eine Datei kann sequentiell geschrieben werden. Diese Schreiboperationen sollen transaktional unterst&#xfc;tzt werden, so dass auch eine Rollback m&#xf6;glich ist. Dazu wird der Bereich des g&#xfc;ltigen Inhalts durch eine Positionsangabe relativ zum Dateianfang gegeben. Mittels dieser Positionsangabe wird ein eventuelles Rollback implementiert, denn mittels der Dateiposition kann der Inhalt der Datei relativ zu dieser Position wiederhergestellt werden. </p>
<p>Aus der Implementierung ergibt sich, dass nur sequentiell in die Datei geschrieben werden kann.</p>
<p>Im Rahmen einer Transaktion soll bei einem Rollback der Stand der Datei zu Beginn der Transaktion wiederhergestellt werden. Die Anfangsdateiposition wird aus der aktuellen L&#xe4;nge der Datei ermittelt. </p>
<p>Folgender Testfall beschreibt die Arbeit mit dieser Klasse <tt>org.csc.phynixx.tutorial.TAEnabledUTFWriter</tt></p>

<div class="source">
<pre>package org.csc.phynixx.tutorial;
 . . . 
public void testTAEnabledUTFWriter() throws Exception {

  File file = this.tmpDir.assertExitsFile(&quot;my_test.tmp&quot;);

  TAEnabledUTFWriter writer = TAEnabledUTFWriter.createWriter(file);
  try {
      // schreibe zwei String in die Datei
      writer.write(&quot;AA&quot;).write(&quot;BB&quot;);
  } finally {
     // schliesst Datei, laesst aber die Inhalt bestehen.
     writer.close();
   }

   // Liest den Inhalt der Datei wieder ein
   writer = TAEnabledUTFWriter.recoverWriter(file);
   try {
     List&lt;String&gt; content = writer.getContent();
     Assert.assertEquals(2, content.size());
     Assert.assertEquals(&quot;AA&quot;, content.get(0));
     Assert.assertEquals(&quot;BB&quot;, content.get(1));
   } finally {
       writer.close();
  }      
}
</pre></div>
<p><i>Listing 1 :</i> Arbeit mit der Ressource <tt>TAEnabledUTFWriter</tt></p></div>
<div class="section">
<h2>lokale Transaktionen<a name="lokale_Transaktionen"></a></h2>
<p>Diese Funktionalit&#xe4;t soll transaktional unterst&#xfc;tzt werden. Dazu muss sie im ersten Schritt das Interface <tt>org.csc.phynixx.connection.IPhynixxConnection</tt> unterst&#xfc;tzen. Dort wird geregelt, wie die transaktionale Ressource (in unserem Fall <i>TAEnabledUTFWriter</i>) auf die unterschiedlichen Situationen innerhalb einer Transaktionn reagieren soll.</p>

<table border="0" class="table table-striped">

<tr class="a">
<th>Methode</th>
<th>Beschreibung</th></tr> 

<tr class="b">
<td>rollback</td>
<td>Die Datei soll auf den initialen Inhalt zur&#xfc;ckgesetzt werden</td></tr>

<tr class="a">
<td>commit</td>
<td>Nichts geschieht, da Datei fortlaufend beschrieben wird und damit im Gutfall konsistent ist</td></tr>

<tr class="b">
<td>reset</td>
<td>Connection wird neu genutzt und der bisherige Zustand wird verworfen</td></tr>

<tr class="a">
<td>close</td>
<td>Connection wird nicht weiter genutzt und freigesetzt</td></tr>
</table>
<p>*Tabelle 1 :*Implementierungen des Interfaces <tt>IPhynixxConnection</tt> &lt;nbsp;&gt; Die Funktionalit&#xe4;t zum seqnetiellen Schreiben finden sich in <tt>TAEnabledUTFWriter</tt>, eine Subklasse von <tt>IPhynixxConnection</tt>. Dort werden folgende Methoden implementiert </p>
<table border="0" class="table table-striped"> 
<tr class="a">
<th>Methode</th>
<th>Beschreibung</th></tr> 
<tr class="b">
<td>open</td>
<td>&#xd6;ffnet eine Datei zum schreiben. Es wird die aktuelle Position der Datei als &#x2018;rollback&#x2019;-Information gesichert</td></tr> 
<tr class="a">
<td>resetContent</td>
<td>Inhalt der Datei wird verworfen. </td></tr> 
<tr class="b">
<td>readContent</td>
<td>List den Inhalt aus Datei</td></tr> 
<tr class="a">
<td>write</td>
<td>Es wird ein String in die Datei geschrieben.</td></tr> </table> &#160;
<p>Die Methoden <i>open, resetContent, write</i> ver&#xe4;ndern den Zustand der Ressource und m&#xfc;ssen daher an einer Transaktion teilnehmen, damit diese korrekt funktionieren. Dies wird durch die Annotation <tt>@RequiresTransaction</tt> angezeigt.</p>
<p>Um sicherzustellen, dass die Datei auch bei unvorhergesehenem Abbruch der Transaktion wiederherzustellen ist, wird ein persistenter <i>XADataRecorder</i> angefordert. Mittels diesem k&#xf6;nnen Wiederherstellungsinformation gesichert werden. Dazu muss das Interface <i>import org.csc.phynixx.connection.IXADataRecorderAware</i> implementiert werden. Sobald eine Transaktion ge&#xf6;ffnet wird, so wird der eine XARecoder via <tt>setXADataRecorder(IXADataRecorder xaDataRecorder)</tt> injeziert.</p>
<p>Es ist sichergestellt, dass der IXADataRecorder injeziert wird, unmittelbar bevor die erste Methode aufgerufen wird, welche durch <tt>@RequireTransaction</tt> annotiert ist. Die Injezierung wird durch den Aufruf dieser Methode ausgel&#xf6;st.</p>
<p>Das Zusammenspiel innerhalb einer (lokalen) Transaktion ist in der Testklasse <tt>TransactionalBehaviourTest</tt> zu beobachten.</p>

<div class="source">
<pre>@Test
public void testCommit() throws Exception {

    File file = this.tmpDir.assertExitsFile(&quot;my_test.tmp&quot;);

    TAEnabledUTFWriter connection = this.connectionFactory.getConnection();
    connection.open(file);
    try {
        connection.write(&quot;AA&quot;).write(&quot;BB&quot;);
        connection.commit();
    } finally {
        connection.close();
    }

    TAEnabledUTFWriterImpl recoverWriter = new TAEnabledUTFWriterImpl();
    try {
        recoverWriter.open(file);
        List&lt;String&gt; content = recoverWriter.getContent();
        Assert.assertEquals(2, content.size());
        Assert.assertEquals(&quot;AA&quot;, content.get(0));
        Assert.assertEquals(&quot;BB&quot;, content.get(1));

    } finally {
        recoverWriter.close();
    }
}
</pre></div>
<p><i>Listing 2 :</i> Beipiel die Einbindung der Ressource <tt>TAEnabledUTFWriter</tt> in eine lokale Transaktion</p>
<p>Interessant ist insbesondere das Setup des Tests</p>

<div class="source">
<pre>private PhynixxManagedConnectionFactory&lt;TAEnabledUTFWriter&gt; connectionFactory = null;

@Before
public void setUp() throws Exception {
    // configuring the log-system (e.g. log4j)
    TestUtils.configureLogging();
    this.tmpDir = new TmpDirectory(&quot;test&quot;);

    this.connectionFactory =
            new PhynixxManagedConnectionFactory&lt;TAEnabledUTFWriter&gt;(
                            new TAEnabledUTFWriterFactoryImpl());
    IDataLoggerFactory loggerFactory = new FileChannelDataLoggerFactory(
                             &quot;ta_enabled&quot;, this.tmpDir.getDirectory());
    IPhynixxLoggerSystemStrategy&lt;TAEnabledUTFWriter&gt; strategy = 
            new LoggerPerTransactionStrategy&lt;TAEnabledUTFWriter&gt;(loggerFactory);
    connectionFactory.setLoggerSystemStrategy(strategy);
}
</pre></div>
<p><i>Listing 3 :</i> Setup der Testumgebung</p>

<ul>
  
<li>Die ConnectionFactory <tt>TAEnabledUTFWriterFactoryImpl</tt> liefert die Connections der Ressource <tt>TAEnabledUTFWriter</tt>. Sie wird zusammen mit <tt>TAEnabledUTFWriterFactory</tt> bereitgestellt.</li>
  
<li>Um einen persistenten <tt>XADataRecorder</tt> injezieren zu k&#xf6;nnen, muss eine eine Persistenzverfahren an die Factory &#xfc;bergeben werden, welches die Wiederherstellungsinformationen sichert. In dieser Strategie wird festgelegt, auf welche Weise die Wiederherstellungsinformationen gesichert werden. Die Strategie <tt>LoggerPerTransactionStrategy</tt> erzeugt DataRecoder im Filesystem.</li>
  
<li>Um einfach tempor&#xe4;re Dateien erzeugen zu k&#xf6;nnen, bietet die Klasse <tt>TmpDirectory</tt> ein Interface, tempor&#xe4;re Datei und Verzeichnisse zu erzeugen</li>
</ul>

<div class="source">
<pre>@Test
public void testRollback() throws Exception {

    File file = this.tmpDir.assertExitsFile(&quot;my_test.tmp&quot;);

    TAEnabledUTFWriter connection1 = this.connectionFactory.getConnection();
    try {
        connection1.open(file);
        connection1.write(&quot;AA&quot;).write(&quot;BB&quot;);            
        connection1.commit();
    } finally {
        connection1.close();
    }

    TAEnabledUTFWriter connection2 = this.connectionFactory.getConnection();
    try {
        connection2.open(file);
        connection2.write(&quot;CC&quot;).write(&quot;DD&quot;);
        connection2.rollback();
    } finally {
        connection2.close();
    }

    TAEnabledUTFWriter recoverWriter = this.connectionFactory.getConnection();
    recoverWriter.open(file);
    try {
        List&lt;String&gt; content = recoverWriter.getContent();
        Assert.assertEquals(2, content.size());
        Assert.assertEquals(&quot;AA&quot;, content.get(0));
        Assert.assertEquals(&quot;BB&quot;, content.get(1));

    } finally {
        recoverWriter.close();
    }
}
</pre></div>
<p><i>Listing 4 :</i> Beipiel die Einbindung der Ressource <tt>TAEnabledUTFWriter</tt> in eine lokale Transaktion mit Rollback</p></div>
<div class="section">
<h2><i>managed connection</i><a name="managed_connection"></a></h2>
<p>Eine Connection in ihrer reinen Form gegeben durch die Implementierung <tt>TAEnabledUTFWriterImpl</tt> reicht nicht aus, um innerhalb einer Transaktion zu agieren. </p>
<p>Ein solche Connection mu&#xdf; zu einer <i>managed connection</i> erweitert werden. Diese Erweiterung steuert viele Aspekte bei, welche eine <i>connection</i> erst zu einer transaktionalen Ressource machen.</p>
<p>Um diese Aspekte zu erhalten, muss eine <tt>PhynixxManagedConnectionFactory</tt> eingesetzt werden. Sie veredelt eine normale Connection zu einer <i>managed connection</i> und damit zu einer transaktionalen Ressource. </p>

<div class="source">
<pre>this.connectionFactory =
            new PhynixxManagedConnectionFactory&lt;TAEnabledUTFWriter&gt;(new TAEnabledUTFWriterFactoryImpl());
</pre></div>
<p><i>Abbildung 4</i> : Beispiel einer PhynixxManagedConnectionFactory</p>
<p>Connection, welche mit dieser Factory erzeugt worden sind, sind voll funktiontionsf&#xe4;hige transaktionale Ressourcen und k&#xf6;nnen an lokalen Transaktionen teilnehmen. Jede <i>managed connection</i> besitzt eine assoziierte <i>connection</i>; bei uns vom Typ <tt>TAEnabledUTFWriter</tt>. Bei Bedarf wendet sich die <i>managed connection</i> an diese. </p>
<div class="section">
<h3>Workflow einer <i>managed connection</i><a name="Workflow_einer_managed_connection"></a></h3>
<p>Der Workflow einer <i>managed connection</i> innerhalb einer Transaktion kann mittels eines Listeners (siehe <i>Observer Pattern</i> [GoF] ) beobachtet werden. Auf diese Weise kann auch die Funktionalit&#xe4;t einer <i>managed connection</i> erweitert werden. </p>
<p>Dazu muss ein Listener vom Typ <tt>IPhynixxManagedConnectionListener</tt> implementiert werden. Um die ManagedConnectionFactory zu beauftragen, jede <i>managed connection</i> mit diesem Listener zu verzieren, wird ihr ein <tt>IPhynixxManagedConnectionDecorator</tt> &#xfc;bergeben werden. Dieser wird bei der Instanzierung einer <i>managed connection</i> gerufen und kann diese wie gew&#xfc;nscht ver&#xe4;ndern. </p>
<p>Mittels dies Prinzips kann eine ManagedConnection auch um eigene Aspekte erweitert werden. </p>

<div class="source">
<pre>  connectionFactory.addManagedConnectionDecorator(
             new DumpManagedConnectionListener&lt;TAEnabledUTFWriter&gt;())
</pre></div>
<p><i>Abbildung 5 </i>: Beobachten des Workflows einer <i>managed connection</i></p>
<p><tt>DumpManagedConnectionListener</tt> implementiert sowohl <tt>IPhynixxManagedConnectionListener</tt> als auch <tt>IPhynixxManagedConnectionDecorator</tt> </p></div></div>
<div class="section">
<h2>Globale Transaktionen<a name="Globale_Transaktionen"></a></h2></div>
<div class="section">
<h2>Wiederherstellungsinformationen<a name="Wiederherstellungsinformationen"></a></h2>
<p>TBD</p></div>
<div class="section">
<h2>Integration mit Spring<a name="Integration_mit_Spring"></a></h2>
<p><b>TBD</b></p>
<div class="section">
<h3>lokale Transaktionen<a name="lokale_Transaktionen"></a></h3></div>
<div class="section">
<h3>globale Transaktionen<a name="globale_Transaktionen"></a></h3></div></div>
                  </div>
            </div>
          </div>

    <hr/>

    <footer>
            <div class="container-fluid">
                      <div class="row-fluid">
                              <p >Copyright &copy;                   2014.
          All rights reserved.      
                    
      </p>
        </div>

        
        
                </div>
    </footer>
        </body>
</html>
